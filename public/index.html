<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Teacher All in One AI Chat</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.5.1/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://unpkg.com/file-saver/dist/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script src="https://unpkg.com/html-docx-js-typescript/dist/html-docx.js"></script>
  
  <!-- This script is from the incoming version, required for the database browser -->
  <script src="books.js"></script>

  <style>
    /* --- Base Styles from Previous Version --- */
    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f5f7fa;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }
    .message {
      display: flex;
      align-items: flex-end;
      margin: 8px 0;
      width: fit-content;
      max-width: 90%;
    }
    .bot { flex-direction: row; }
    .user {
      flex-direction: row-reverse;
      align-self: flex-end;
    }
    .bubble {
      padding: 12px 16px;
      border-radius: 18px;
      animation: fadeIn 0.3s ease-in;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 16px;
      display: inline-block;
      background-color: #eeeeee;
    }
    .user .bubble { background-color: #d2f0ff; }
    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      margin: 0 8px;
    }
    #input-area {
      display: flex;
      flex-direction: column;
      padding: 10px;
      background: white;
      border-top: 1px solid #ccc;
    }
    .input-top-files {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 6px;
    }
    .file-item {
      display: flex;
      align-items: center;
      background: #f0f0f0;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 14px;
      margin-bottom: 6px;
      gap: 10px;
    }
    .file-item span {
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .file-note {
      flex: 1;
      padding: 4px 8px;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .file-item button {
      background: none;
      border: none;
      color: red;
      font-size: 16px;
      cursor: pointer;
    }
    .input-wrapper {
      display: flex;
      align-items: center;
    }
    #user-input {
      flex: 1;
      min-height: 44px;
      max-height: 300px;
      resize: vertical;
      padding: 10px;
      font-size: 1rem;
      border-radius: 8px;
      border: 1px solid #ccc;
    }
    #file-upload { display: none; }
    .tooltip-wrapper {
      position: relative;
      display: inline-block;
    }
    #file-button {
      background-color: white;
      border: none;
      font-size: 20px;
      margin: 0 10px;
      cursor: pointer;
    }
    .tooltip-text {
      visibility: hidden;
      background-color: #333;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      white-space: nowrap;
    }
    .tooltip-wrapper:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    .next-button {
      padding: 10px 20px;
      background-color: #10a37f;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
    }
    h2.centered-heading {
      font-size: 28px;
      margin-bottom: 20px;
      text-align: center;
      width: 100%;
    }
    .select-inline {
      margin-left: 12px;
      margin-top: 4px;
      font-size: 16px;
      font-family: 'Inter', sans-serif;
      padding: 6px;
      border-radius: 6px;
      width: fit-content;
      max-width: 400px;
    }
    .uploaded-file {
      color: rgb(41, 96, 198);
      text-decoration: underline;
      cursor: pointer;
    }
    .uploaded-file:hover { text-decoration: none; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    button.selected {
      background: #10a37f !important;
      border-color: #10a37f !important;
      color: white !important;
    }

    /* --- Merged Styles from Incoming Version --- */
    .book-item {
      padding: 6px 10px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
    }
    .book-item:hover { background: #f7f7f7; }
    .book-item.selected { background: #d2f0ff; }
    .group-title {
      margin: 10px 0 4px;
      font-weight: bold;
      background: #f0f0f0;
      padding: 4px 6px;
    }
    .choice-btn {
      padding: 10px 20px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      transition: all 0.2s ease;
      min-width: 120px;
    }
    .choice-btn:hover { background: #f0f0f0; }
    .choice-btn.selected {
      background: #10a37f;
      color: white;
      border-color: #10a37f;
    }
    #stage-3-ui { /* Renamed to avoid conflicts */
      padding: 20px;
      background: white;
      border-radius: 8px;
      margin: 10px 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #upload-section {
      margin-top: 16px;
      padding: 20px;
      border: 2px dashed #ccc;
      border-radius: 8px;
      text-align: center;
    }
    #db-browser-container {
      margin-top: 16px;
      padding: 16px;
      border: 1px solid #eee;
      border-radius: 8px;
    }
    .source-choice {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      justify-content: center;
    }
    #pdf-preview {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #pdf-container {
      background: #f5f5f5;
      overflow: auto;
    }
    #confirm-selection {
      width: 100%;
      margin-top: 10px;
      font-weight: 500;
    }
    #confirm-selection:hover { background: #0d8c6d !important; }
  </style>
</head>
<body>
  <div style="padding: 10px; background-color: #fff; border-bottom: 1px solid #ddd; text-align: right;">
    <select id="lang-select" style="font-size: 14px; padding: 4px 8px; border-radius: 6px;">
        <option value="eng">English</option>
        <option value="zh">ÁÆÄ‰Ωì‰∏≠Êñá</option>
        <option value="zh-HK">ÁπÅÈ´î‰∏≠Êñá</option>
    </select>
  </div>

  <div id="chat">
    <h2 class="centered-heading">üëã What do you wanna generate?</h2>
  </div>

  <!-- This UI container is from the incoming version, for Stage 3 -->
  <div id="stage-3-ui" style="display: none;">
    <h3 id="question3-title"></h3>
    <div class="source-choice">
      <button class="choice-btn" onclick="showUploadSection()">Upload Files</button>
      <button class="choice-btn" onclick="showDatabaseSection()">Browse Database</button>
    </div>
    <div id="upload-section" style="display: none;">
      <!-- This input is specifically for the Stage 3 UI -->
      <input type="file" id="stage-3-file-upload" accept=".pdf,.doc,.docx,.png,.jpg,.jpeg" multiple onchange="handleStage3FileUpload(this.files)" />
      <p>Drag & drop files here or click to select.</p>
    </div>
    <div id="db-browser-container" style="display: none;">
      <strong id="db-browser-label"></strong>
      <input type="text" id="filter-input" placeholder="üîç Search‚Ä¶" style="width:100%; padding:4px; margin:6px 0;" />
      <div id="item-list" style="max-height: 300px; overflow-y:auto; border: 1px solid #eee; padding: 4px;"></div>
      <div id="pdf-preview" style="display: none; margin-top: 20px;">
        <h4 style="margin-bottom: 10px;">Selected File Preview:</h4>
        <div id="pdf-container" style="width: 100%; height: 500px; border: 1px solid #eee; margin-bottom: 10px;"></div>
        <button id="confirm-selection" class="choice-btn" style="background: #10a37f; color: white;">Confirm Selection</button>
      </div>
    </div>
  </div>

  <div id="input-area">
    <div id="file-preview" class="input-top-files"></div>
    <div class="input-wrapper">
      <textarea id="user-input" rows="2"></textarea>
      <div class="tooltip-wrapper">
        <button id="file-button" onclick="document.getElementById('file-upload').click()">Ôºã</button>
        <span class="tooltip-text">Upload File</span>
      </div>
      <!-- This file input is for general purpose uploads outside of Stage 3 -->
      <input type="file" id="file-upload" multiple />
      <button class="next-button" onclick="handleUserInput()">Next</button>
    </div>
  </div>

  <script>
    // --- Element References ---
    const chat = document.getElementById('chat');
    const input = document.getElementById('user-input');
    const fileInput = document.getElementById('file-upload');
    const filePreview = document.getElementById('file-preview');
    const langSelector = document.getElementById('lang-select');
    const inputArea = document.getElementById('input-area');
    
    // --- State Management ---
    let currentStage = 0;
    const answers = { have: [] }; // Central state for user answers
    const pendingExtractions = new Set();
    let currentLang = langSelector.value;
    let fullMarkdown = '';
    let lastGeneratedForm = null;
    let lastUserMoreMessage = null;
    const refineState = {
        choiceContainer: null,
        optionsContainer: null,
        promptMsg: null,
        botPromptMsg: null,
        userAnswerMsg: null,
        gotItMsg: null,
        lastSelectedBtn: null,
    };

    // --- Configuration ---
    const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    const stages = [
      { promptKey: 'question1', key: 'type', type: 'dropdown',
        options: [
            'Lesson Plan', 'Class Materials (PPT/pictures)', 'Report Card',
            'Student-Work Feedback', 'Subject Question Bank / Assignment',
            'Activity Plan / Extracurricular', 'Admin Helper (PPT / Word)'
        ]
      },
      { promptKey: 'question2', key: 'why', type: 'text' },
      { promptKey: 'question3', key: 'have', type: 'text' }, // This stage will now trigger the new UI
      { promptKey: 'question4', key: 'more', type: 'text' },
      { promptKey: 'question5', key: 'refine', type: 'yesno' }
    ];

    // --- Translations (Merged & Standardized) ---
    const translations = {
        eng: {
            title: "üëã What do you wanna generate?",
            next: "Next",
            upload: "Upload File",
            yes: "Yes",
            no: "No",
            saveBtn: "Save",
            regenerateBtn: "üîç Regenerate with More Detail",
            morePrompt: "Question 4/5: ‚úèÔ∏è Add more details: Comment, Grade, Number of Students, Duration, Length",
            refineWhich: "üß© Which part(s) would you like to be more specific?",
            done: "üéâ Got it! Let me know if you need anything else.",
            question1: "Question 1/5: üëá Please select a type:",
            question2: "Question 2/5: üí≠ Why do you need this? (e.g. for student of grade 2 to have maths class, for parents meeting next week)",
            question3: "Question 3/5: üìé What do you have on hand? (You can upload files or browse our database)",
            question4: "Question 4/5: ‚úèÔ∏è Add more details: Comment, Grade, Number of Students, Duration, Length",
            question5: "Question 5/5: üîç Do you want to make any part more specific?",
            pleaseFill: "Please provide some input or select a file.",
            noExtractedText: "No extracted text found ‚Äì please upload a PDF / Word / image first.",
            noTemplateFound: "‚ö†Ô∏è No corresponding template was found to generate content!",
            atLeastOnePart: "Please select at least one part to refine.",
            generationFailed: "‚ùå Generation failed. Please try again.",
            pleaseRefine: "‚úÖ Yes, please refine.",
            noThanks: "‚ùå No, that‚Äôs enough.",
            replacedMsg: "üîÑ \"{filename}\" replaced.",
            replaceConfirm: "Replace previously uploaded \"{filename}\"?",
            infoCollected: "‚úÖ All info collected. Ready to generate!",
            type_lesson: "Lesson Plan",
            type_materials: "Class Materials (PPT/pictures)",
            type_report: "Report Card",
            type_feedback: "Student‚ÄëWork Feedback",
            type_bank: "Subject Question Bank / Assignment",
            type_activity: "Activity Plan / Extracurricular",
            type_admin: "Admin Helper (PPT / Word)",
            ph_comment: "Comment (optional)",
            ph_grade: "Grade (optional)",
            ph_students: "Number of Students",
            ph_duration: "Duration (e.g., 45 mins)",
            ph_length: "Length (Short / Medium / Long)",
            pleaseWait: "Please wait for 1 minute‚Ä¶",
            pleaseWaitVA: "Your Visual Assets is delivering‚Ä¶",
            ph_input: "Type something...",
            details: "Details",
            label_comment: "Comment",
            label_grade: "Grade",
            label_students: "Number of Students",
            label_duration: "Duration",
            label_length: "Length",
            na: "N/A",
            browseFiles: "üìÅ Browse files from database:",
            uploadFiles: "Upload Files",
            browseDatabase: "Browse Database",
            confirmSelection: "Confirm Selection",
            exportDocx: "Export to .docx"
        },
        zh: {},
        "zh-HK": {}
    };
    translations.zh = { ...translations.eng,
        title: "üëã ‰Ω†ÊÉ≥ÁîüÊàê‰ªÄ‰πàÔºü", next: "‰∏ã‰∏ÄÊ≠•", upload: "‰∏ä‰º†Êñá‰ª∂", yes: "ÊòØ", no: "Âê¶", saveBtn: "‰øùÂ≠ò",
        regenerateBtn: "üîç ÈáçÊñ∞ÁîüÊàêÂπ∂‰∏∞ÂØåÁªÜËäÇ", morePrompt: "ÈóÆÈ¢ò 4/5Ôºö‚úèÔ∏è ËØ∑Ë°•ÂÖÖÊõ¥Â§ö‰ø°ÊÅØÔºöÊ≥®Èáä„ÄÅÂπ¥Á∫ß„ÄÅÂ≠¶Áîü‰∫∫Êï∞„ÄÅÊó∂Èïø„ÄÅÈïøÂ∫¶",
        refineWhich: "üß© ‰Ω†ÊÉ≥ËÆ©Âì™‰∫õÈÉ®ÂàÜÊõ¥ÂÖ∑‰ΩìÔºü", done: "üéâ ÊòéÁôΩ‰∫ÜÔºÅÂ¶ÇÊúâÂÖ∂‰ªñÈúÄÊ±ÇËØ∑ÂëäËØâÊàë„ÄÇ",
        question1: "ÈóÆÈ¢ò 1/5Ôºöüëá ËØ∑ÈÄâÊã©‰∏Ä‰∏™Á±ªÂûãÔºö", question2: "ÈóÆÈ¢ò 2/5Ôºöüí≠ ‰Ω†‰∏∫‰ªÄ‰πàÈúÄË¶ÅËøô‰∏™ÔºüÔºà‰æãÂ¶ÇÔºö‰∏∫‰∫åÂπ¥Á∫ßÂ≠¶Áîü‰∏äÁöÑÊï∞Â≠¶ËØæÔºåÊàñÊòØ‰∏ãÂë®ÁöÑÂÆ∂Èïø‰ºöÔºâ",
        question3: "ÈóÆÈ¢ò 3/5Ôºöüìé ‰Ω†Áé∞Âú®Êâã‰∏äÊúâ‰ªÄ‰πàËµÑÊñôÔºüÔºà‰Ω†ÂèØ‰ª•‰∏ä‰º†Êñá‰ª∂ÊàñÊµèËßàÊàë‰ª¨ÁöÑÊï∞ÊçÆÂ∫ìÔºâ",
        question4: "ÈóÆÈ¢ò 4/5Ôºö‚úèÔ∏è ËØ∑Ë°•ÂÖÖÊõ¥Â§ö‰ø°ÊÅØÔºöÊ≥®Èáä„ÄÅÂπ¥Á∫ß„ÄÅÂ≠¶Áîü‰∫∫Êï∞„ÄÅÊó∂Èïø„ÄÅÈïøÂ∫¶", question5: "ÈóÆÈ¢ò 5/5Ôºöüîç ÊòØÂê¶Â∏åÊúõÊüê‰∫õÈÉ®ÂàÜÊõ¥ÂÖ∑‰ΩìÔºü",
        pleaseFill: "ËØ∑Êèê‰æõ‰∏Ä‰∫õËæìÂÖ•ÊàñÈÄâÊã©‰∏Ä‰∏™Êñá‰ª∂„ÄÇ", noExtractedText: "Êú™ÊâæÂà∞ÊèêÂèñÁöÑÊñáÊú¨ ‚Äì ËØ∑‰∏ä‰º† PDF / Word / ÂõæÁâáÊñá‰ª∂„ÄÇ",
        noTemplateFound: "‚ö†Ô∏è Êâæ‰∏çÂà∞ÂØπÂ∫îÁöÑÁîüÊàêÊ®°ÊùøÔºÅ", atLeastOnePart: "ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÁªÜÂåñÁöÑÈÉ®ÂàÜ„ÄÇ", generationFailed: "‚ùå ÁîüÊàêÂ§±Ë¥•„ÄÇËØ∑ÈáçËØï„ÄÇ",
        pleaseRefine: "‚úÖ ÊòØÁöÑÔºåËØ∑ÁªÜÂåñ„ÄÇ", noThanks: "‚ùå ‰∏çÁî®‰∫Ü„ÄÇ", replacedMsg: "üîÑ Â∑≤ÊõøÊç¢\"{filename}\"„ÄÇ",
        replaceConfirm: "ÊòØÂê¶ÊõøÊç¢‰πãÂâç‰∏ä‰º†ÁöÑ\"{filename}\"Ôºü", infoCollected: "‚úÖ ÊâÄÊúâ‰ø°ÊÅØÂ∑≤Êî∂ÈõÜÔºåÂáÜÂ§áÁîüÊàêÔºÅ",
        type_lesson: "ËØæÁ®ãÊïôÊ°à", type_materials: "ËØæÂ†ÇÁ¥†Êùê (PPT/ÂõæÁâá)", type_report: "ÊàêÁª©Âçï", type_feedback: "‰ΩúÂìÅÂèçÈ¶à",
        type_bank: "È¢òÂ∫ì / ‰Ωú‰∏ö", type_activity: "Ê¥ªÂä®ÊñπÊ°à", type_admin: "Ë°åÊîøÊñáÊ°£ (PPT/Word)",
        ph_comment: "Ê≥®ÈáäÔºàÂèØÈÄâÔºâ", ph_grade: "Âπ¥Á∫ßÔºàÂèØÈÄâÔºâ", ph_students: "Â≠¶Áîü‰∫∫Êï∞", ph_duration: "Êó∂ÈïøÔºà‰æãÂ¶Ç 45 ÂàÜÈíüÔºâ",
        ph_length: "ÈïøÂ∫¶ÔºàÁü≠ / ‰∏≠ / ÈïøÔºâ", pleaseWait: "ËØ∑Á≠âÂæÖ 1 ÂàÜÈíü‚Ä¶", pleaseWaitVA: "ÊÇ®ÁöÑÊïôÊùêÊ≠£Âú®ÈÄÅ‰∏ä...",
        ph_input: "ËØ∑ËæìÂÖ•ÂÜÖÂÆπ‚Ä¶", details: "ËØ¶ÊÉÖ", label_comment: "Ê≥®Èáä", label_grade: "Âπ¥Á∫ß", label_students: "Â≠¶Áîü‰∫∫Êï∞",
        label_duration: "Êó∂Èïø", label_length: "ÈïøÂ∫¶", na: "Êú™Â°´ÂÜô",
        browseFiles: "üìÅ ‰ªéÊï∞ÊçÆÂ∫ì‰∏≠ÈÄâÊã©Êñá‰ª∂Ôºö", uploadFiles: "‰∏ä‰º†Êñá‰ª∂", browseDatabase: "ÊµèËßàÊï∞ÊçÆÂ∫ì",
        confirmSelection: "Á°ÆËÆ§ÈÄâÊã©", exportDocx: "ÂØºÂá∫Âà∞ .docx"
    };
    translations["zh-HK"] = { ...translations.eng,
        title: "üëã ‰Ω†ÊÉ≥Ë¶ÅÁîüÊàê‰ªÄÈ∫ºÔºü", next: "‰∏ã‰∏ÄÊ≠•", upload: "‰∏äÂÇ≥Ê™îÊ°à", yes: "ÊòØ", no: "Âê¶", saveBtn: "ÂÑ≤Â≠ò",
        regenerateBtn: "üîç ÈáçÊñ∞ÁîüÊàê‰∏¶Ë±êÂØåÁ¥∞ÁØÄ", morePrompt: "ÂïèÈ°å 4/5Ôºö‚úèÔ∏è Ë´ãË£úÂÖÖÊõ¥Â§öÁ¥∞ÁØÄÔºöË®ªËß£„ÄÅÂπ¥Á¥ö„ÄÅÂ≠∏Áîü‰∫∫Êï∏„ÄÅÊôÇÈï∑„ÄÅÈï∑Â∫¶",
        refineWhich: "üß© ‰Ω†ÊÉ≥ËÆìÂì™‰∫õÈÉ®ÂàÜÊõ¥ÂÖ∑È´îÔºü", done: "üéâ ÊòéÁôΩÔºÅÂ¶ÇÊúâÂÖ∂‰ªñÈúÄË¶ÅË´ãÂëäË®¥Êàë„ÄÇ",
        question1: "ÂïèÈ°å 1/5Ôºöüëá Ë´ãÈÅ∏Êìá‰∏ÄÂÄãÈ°ûÂûãÔºö", question2: "ÂïèÈ°å 2/5Ôºöüí≠ ‰Ω†ÁÇ∫‰ªÄÈ∫ºÈúÄË¶ÅÈÄôÂÄãÔºüÔºà‰æãÂ¶ÇÔºöÁÇ∫‰∫åÂπ¥Á¥öÂ≠∏Áîü‰∏äÁöÑÊï∏Â≠∏Ë™≤ÔºåÊàñÊòØ‰∏ãÈÄ±ÁöÑÂÆ∂Èï∑ÊúÉÔºâ",
        question3: "ÂïèÈ°å 3/5Ôºöüìé ‰Ω†ÁèæÂú®Êâã‰∏äÊúâ‰ªÄÈ∫ºË≥áÊñô (‰Ω†ÂèØ‰ª•‰∏äÂÇ≥Ê™îÊ°àÊàñÁÄèË¶ΩÊàëÂÄëÁöÑÊï∏ÊìöÂ∫´)",
        question4: "ÂïèÈ°å 4/5Ôºö‚úèÔ∏è Ë´ãË£úÂÖÖÊõ¥Â§öÁ¥∞ÁØÄÔºöË®ªËß£„ÄÅÂπ¥Á¥ö„ÄÅÂ≠∏ÁîüÊï∏Èáè„ÄÅÊôÇÈñì„ÄÅÈï∑Â∫¶", question5: "ÂïèÈ°å 5/5Ôºöüîç ÊòØÂê¶ÈúÄË¶ÅÊõ¥ÂÖ∑È´îÁöÑÈÉ®ÂàÜÔºü",
        pleaseFill: "Ë´ãÊèê‰æõ‰∏Ä‰∫õËº∏ÂÖ•ÊàñÈÅ∏Êìá‰∏ÄÂÄãÊñá‰ª∂„ÄÇ", noExtractedText: "Êú™ÊâæÂà∞ÊèêÂèñÂÖßÂÆπ ‚Äì Ë´ãÂÖà‰∏äÂÇ≥ PDF / Word / ÂúñÁâá„ÄÇ",
        noTemplateFound: "‚ö†Ô∏è Êâæ‰∏çÂà∞Â∞çÊáâÁöÑÁîüÊàêÊ®°ÊùøÔºÅ", atLeastOnePart: "Ë´ãËá≥Â∞ëÈÅ∏Êìá‰∏ÄÂÄãÈúÄË¶ÅÁ¥∞ÂåñÁöÑÈÉ®ÂàÜ„ÄÇ", generationFailed: "‚ùå ÁîüÊàêÂ§±Êïó„ÄÇË´ãÂÜçË©¶‰∏ÄÊ¨°„ÄÇ",
        pleaseRefine: "‚úÖ ÊòØÁöÑÔºåË´ãÁ¥∞Âåñ„ÄÇ", noThanks: "‚ùå ‰∏çÁî®‰∫Ü„ÄÇ", replacedMsg: "üîÑ Â∑≤ÊõøÊèõ\"{filename}\"„ÄÇ",
        replaceConfirm: "ÊòØÂê¶ÊõøÊèõ‰πãÂâç‰∏äÂÇ≥ÁöÑ\"{filename}\"Ôºü", infoCollected: "‚úÖ ÊâÄÊúâË≥áË®äÂ∑≤Êî∂ÈõÜÔºåÊ∫ñÂÇôÁîüÊàêÔºÅ",
        type_lesson: "Ë™≤Á®ãÊïôÊ°à", type_materials: "Ë™≤Â†ÇÁ¥†Êùê (PPT/ÂúñÁâá)", type_report: "ÊàêÁ∏æÂñÆ", type_feedback: "‰ΩúÂìÅÂõûÈ•ã",
        type_bank: "È°åÂ∫´ / ‰ΩúÊ•≠", type_activity: "Ê¥ªÂãïË®àÁï´", type_admin: "Ë°åÊîøÊñá‰ª∂ (PPT/Word)",
        ph_comment: "Ë®ªËß£ÔºàÂèØÈÅ∏Ôºâ", ph_grade: "Âπ¥Á¥öÔºàÂèØÈÅ∏Ôºâ", ph_students: "Â≠∏Áîü‰∫∫Êï∏", ph_duration: "ÊôÇÈï∑Ôºà‰æãÂ¶Ç 45 ÂàÜÈêòÔºâ",
        ph_length: "Èï∑Â∫¶ÔºàÁü≠ / ‰∏≠ / Èï∑Ôºâ", pleaseWait: "Ë´ãÁ≠âÂæÖ 1 ÂàÜÈêò‚Ä¶", pleaseWaitVA: "ÊÇ®ÁöÑÊïôÊùêÊ≠£Âú®ÈÄÅ‰∏ä...",
        ph_input: "Ë´ãËº∏ÂÖ•ÂÖßÂÆπ‚Ä¶", details: "Ë©≥ÊÉÖ", label_comment: "Ë®ªËß£", label_grade: "Âπ¥Á¥ö", label_students: "Â≠∏Áîü‰∫∫Êï∏",
        label_duration: "ÊôÇÈï∑", label_length: "Èï∑Â∫¶", na: "Êú™Â°´ÂØ´",
        browseFiles: "üìÅ ÂæûÊï∏ÊìöÂ∫´‰∏≠ÁÄèË¶ΩÊ™îÊ°àÔºö", uploadFiles: "‰∏äÂÇ≥Ê™îÊ°à", browseDatabase: "ÁÄèË¶ΩÊï∏ÊìöÂ∫´",
        confirmSelection: "Á¢∫Ë™çÈÅ∏Âèñ", exportDocx: "Â∞éÂá∫Ëá≥ .docx"
    };

    const templateSections = {
      "Lesson Plan": { eng: [ "Lesson Title / Subject Area", "Learning Goals & Measurable Objectives", "Prerequisite Knowledge", "Materials / Resources List", "Step‚Äëby‚Äëstep Procedure & Timing", "Assessment / Evidence of Learning", "Differentiation / Accommodations", "Anticipated Difficulties/ Challenges ‚Üí Solution", "Follow‚Äëup / Reflection box" ], zh: [ "ËØæÈ¢ò / Â≠¶ÁßëÈ¢ÜÂüü", "Â≠¶‰π†ÁõÆÊ†á & ÂèØÊµãÈáèÊåáÊ†á", "ÂÖàÂ§áÁü•ËØÜ", "ÊùêÊñô / ËµÑÊ∫êÊ∏ÖÂçï", "ËØæÂ†ÇÊ≠•È™§ & Êó∂Èó¥ÂàÜÈÖç", "ËØÑ‰º∞ÊñπÂºè / Â≠¶‰π†ËØÅÊçÆ", "Â∑ÆÂºÇÂåñÊïôÂ≠¶ / ÈÄÇÂ∫îÁ≠ñÁï•", "È¢ÑÂà§ÈöæÁÇπ / ÊåëÊàò ‚Üí Ëß£ÂÜ≥ÊñπÊ°à", "ËØæÂêéË∑üËøõ / ÂèçÊÄù" ], "zh-HK": [ "Ë™≤Á®ãÊ®ôÈ°å / ÁßëÁõÆÈ†òÂüü", "Â≠∏ÁøíÁõÆÊ®ô & ÂèØË°°ÈáèÊåáÊ®ô", "ÂÖàÂÇôÁü•Ë≠ò", "ÊùêÊñô / Ë≥áÊ∫êÊ∏ÖÂñÆ", "Ê≠•È©üÊµÅÁ®ã & ÊôÇÈñìÈÖçÁΩÆ", "Ë©ïÈáèÊñπÂºè / Â≠∏ÁøíË≠âÊìö", "Â∑ÆÁï∞ÂåñÊïôÂ≠∏ / Ë™øÊï¥ÊñπÊ°à", "È†êÊúüÂõ∞Èõ£ / ÊåëÊà∞ ‚Üí Ëß£Ê±∫Á≠ñÁï•", "ÂæåÁ∫åËøΩËπ§ / ÂèçÊÄù" ] },
      "Class Materials (PPT/pictures)": { eng: [ "Presentation Topic / Focus Question", "Expected Audience (Grade or Course)", "Key Points / Slide Outline", "Desired Visual Assets (images, charts, video links)", "Desired Audio Assets (music, sound clips)", "Branding Elements (school logo, colors, fonts)", "Speaker‚Äënote Depth (none / bullet / full script)" ], zh: [ "ÊºîÁ§∫‰∏ªÈ¢ò / ÂÖ≥Ê≥®ÈóÆÈ¢ò", "ÁõÆÊ†áÂèó‰ºóÔºàÂπ¥Á∫ßÊàñËØæÁ®ãÔºâ", "ÂÖ≥ÈîÆË¶ÅÁÇπ / ÂπªÁÅØÁâáÂ§ßÁ∫≤", "ËßÜËßâÁ¥†ÊùêÈúÄÊ±ÇÔºàÂõæÁâá„ÄÅÂõæË°®„ÄÅËßÜÈ¢ëÈìæÊé•Ôºâ", "Èü≥È¢ëÁ¥†ÊùêÈúÄÊ±ÇÔºàÈü≥‰πê„ÄÅÈü≥ÊïàÔºâ", "ÂìÅÁâåÂÖÉÁ¥†ÔºàÊ†°ÂæΩ„ÄÅËâ≤ÂΩ©„ÄÅÂ≠ó‰ΩìÔºâ", "ÊºîËÆ≤ËÄÖÂ§áÊ≥®Ê∑±Â∫¶ÔºàÊó† / Ë¶ÅÁÇπ / ÂÖ®ËÑöÊú¨Ôºâ" ], "zh-HK": [ "Á∞°Â†±‰∏ªÈ°å / ÁÑ¶ÈªûÂïèÈ°å", "È†êÊúüÂèóÁúæÔºàÂπ¥Á¥öÊàñË™≤Á®ãÔºâ", "ÈáçÈªû / ÊäïÂΩ±ÁâáÂ§ßÁ∂±", "Ë¶ñË¶∫Á¥†ÊùêÈúÄÊ±ÇÔºàÂúñÁâá„ÄÅÂúñË°®„ÄÅÂΩ±ÁâáÈèàÊé•Ôºâ", "Èü≥Ë®äÁ¥†ÊùêÈúÄÊ±ÇÔºàÈü≥Ê®Ç„ÄÅÈü≥ÊïàÔºâ", "ÂìÅÁâåÂÖÉÁ¥†ÔºàÊ†°ÂæΩ„ÄÅËâ≤ÂΩ©„ÄÅÂ≠óÈ´îÔºâ", "Ë¨õËÄÖÂÇôË®ªÊ∑±Â∫¶ÔºàÁÑ° / Ë¶ÅÈªû / ÂÆåÊï¥Á®øÔºâ" ] },
      "Report Card": { eng: [ "Student & Class Identifiers", "Term / Grading Period", "Subject List & Grade Scale", "Attendance Figures", "Behavior /Work‚ÄëHabit Ratings", "Other Learning Experience/ Extra-curricular activities", "Award", "Teacher Narrative Comments", "Parent signature flag" ], zh: [ "Â≠¶Áîü‰∏éÁè≠Á∫ß‰ø°ÊÅØ", "Â≠¶Êúü / ÊàêÁª©Âë®Êúü", "ÁßëÁõÆÂàóË°®‰∏éËØÑÂàÜÊ†áÂáÜ", "Âá∫Âã§Êï∞ÊçÆ", "Ë°å‰∏∫ / Â≠¶‰π†‰π†ÊÉØËØÑÂàÜ", "ÂÖ∂‰ªñÂ≠¶‰π†ÁªèÂéÜ / ËØæÂ§ñÊ¥ªÂä®", "Â•ñÂä±", "ÊïôÂ∏àËØÑËØ≠", "ÂÆ∂ÈïøÁ≠æÂêçÈ°π" ], "zh-HK": [ "Â≠∏ÁîüËàáÁè≠Á¥öË≥áË®ä", "Â≠∏Êúü / ÊàêÁ∏æÈÄ±Êúü", "ÁßëÁõÆÊ∏ÖÂñÆËàáË©ïÂàÜÊ®ôÊ∫ñ", "Âá∫Âã§Êï∏Êìö", "Ë°åÁÇ∫ / Â≠∏ÁøíÁøíÊÖ£Ë©ïÂàÜ", "ÂÖ∂‰ªñÂ≠∏ÁøíÁ∂ìÈ©ó / Ë™≤Â§ñÊ¥ªÂãï", "ÁçéÂãµ", "ÊïôÂ∏´Ë©ïË™û", "ÂÆ∂Èï∑Á∞ΩÂêçÈ†Ö" ] },
      "Student-Work Feedback": { eng: [ "Student / Assignment ID", "Rubric criteria or \"Glow & Grow\" fields (Strengths, Needs, Next Steps)", "Performance level or score", "Inline examples / Quotes", "Overall Comment", "Next-check-in Date" ], zh: [ "Â≠¶Áîü / ‰Ωú‰∏öÁºñÂè∑", "ËØÑÂàÜÊ†áÂáÜÊàñ‚Äú‰ºòÁÇπ‰∏éÊîπËøõ‚ÄùÂ≠óÊÆµÔºà‰ºòÂäø„ÄÅÈúÄÊîπËøõ„ÄÅ‰∏ã‰∏ÄÊ≠•Ôºâ", "Ë°®Áé∞Á≠âÁ∫ßÊàñÂàÜÊï∞", "Êñá‰∏≠Á§∫‰æã / ÂºïËØ≠", "Êï¥‰ΩìËØÑËØ≠", "‰∏ãÊ¨°ÂõûÈ°æÊó•Êúü" ], "zh-HK": [ "Â≠∏Áîü / ‰ΩúÊ•≠Á∑®Ëôü", "Ë©ïÂàÜÊ®ôÊ∫ñÊàñ„Äå‰∫ÆÈªûËàáÊîπÈÄ≤„ÄçÊ¨Ñ‰ΩçÔºàÂÑ™Âã¢„ÄÅÈúÄÊîπÂñÑ„ÄÅÂæåÁ∫åÊ≠•È©üÔºâ", "Ë°®ÁèæÁ≠âÁ¥öÊàñÂàÜÊï∏", "ÂÖßÊñáÁ§∫‰æã / ÂºïË™û", "Êï¥È´îË©ïË´ñ", "‰∏ãÊ¨°Ê™¢Ë¶ñÊó•Êúü" ] },
      "Subject Question Bank / Assignment": { eng: [ "Subject & Topic Tags", "Standard Alignment", "Question Type (MCQ, open, etc.)", "Difficulty Level", "Question Text", "Answer Choices & Correct Answer", "Explanation / Feedback", "Time Limit Per Item", "Category Folder" ], zh: [ "Â≠¶Áßë‰∏é‰∏ªÈ¢òÊ†áÁ≠æ", "ËØæÁ®ãÊ†áÂáÜÂØπÈΩê", "È¢òÂûãÔºàÈÄâÊã©È¢ò„ÄÅÂºÄÊîæÈ¢òÁ≠âÔºâ", "ÈöæÂ∫¶Á≠âÁ∫ß", "È¢òÂπ≤", "ÈÄâÈ°π‰∏éÊ≠£Á°ÆÁ≠îÊ°à", "Ëß£Êûê / ÂèçÈ¶à", "ÊØèÈ¢òÊó∂Èó¥ÈôêÂà∂", "ÂàÜÁ±ªÊñá‰ª∂Â§π" ], "zh-HK": [ "Â≠∏ÁßëËàá‰∏ªÈ°åÊ®ôÁ±§", "Ë™≤Á∂±Â∞çÊáâ", "È°åÂûãÔºàÈÅ∏ÊìáÈ°å„ÄÅÈñãÊîæÈ°åÁ≠âÔºâ", "Èõ£Â∫¶Á≠âÁ¥ö", "È°åÁõÆÂÖßÂÆπ", "ÈÅ∏È†ÖËàáÊ≠£Á¢∫Á≠îÊ°à", "Ëß£Êûê / ÂõûÈ•ã", "ÊØèÈ°åÊôÇÈñìÈôêÂà∂", "ÂàÜÈ°ûË≥áÊñôÂ§æ" ] },
      "Activity Plan / Extracurricular": { eng: [ "Activity Name & Purpose", "Date(s) / Time block", "Location & Access notes", "Target Group / # Students", "Required materials & Equipment", "Action plan", "Roles & supervision: resources allocation/ responsibilities", "Risk / safety considerations", "Assessment or reflection Method" ], zh: [ "Ê¥ªÂä®ÂêçÁß∞‰∏éÁõÆÁöÑ", "Êó•Êúü / Êó∂Èó¥ÊÆµ", "Âú∞ÁÇπ‰∏éËøõÂÖ•ËØ¥Êòé", "ÁõÆÊ†áÁæ§‰Ωì / Â≠¶Áîü‰∫∫Êï∞", "ÊâÄÈúÄÊùêÊñô‰∏éËÆæÂ§á", "Ë°åÂä®ËÆ°Âàí", "ËÅåË¥£‰∏éÁõëÁù£ÔºöËµÑÊ∫êÈÖçÁΩÆ / ÂàÜÂ∑•", "È£éÈô© / ÂÆâÂÖ®ËÄÉÈáè", "ËØÑ‰º∞ÊàñÂèçÊÄùÊñπÂºè" ], "zh-HK": [ "Ê¥ªÂãïÂêçÁ®±ËàáÁõÆÁöÑ", "Êó•Êúü / ÊôÇÊÆµ", "Âú∞ÈªûËàáÈÄ≤Âá∫Ë™™Êòé", "ÁõÆÊ®ôÂ∞çË±° / Â≠∏Áîü‰∫∫Êï∏", "ÊâÄÈúÄÊùêÊñôËàáË®≠ÂÇô", "Ë°åÂãïË®àÁï´", "ËÅ∑Ë≤¨ËàáÁõ£Áù£ÔºöË≥áÊ∫êÂàÜÈÖç / ‰ªªÂãôÂàÜÂ∑•", "È¢®Èö™ / ÂÆâÂÖ®ËÄÉÈáè", "Ë©ï‰º∞ÊàñÂèçÊÄùÊñπÂºè" ] },
      "Admin Helper (PPT / Word)": { eng: [ "Document Type (agenda, newsletter, handbook, policy)", "Audience", "Key Sections / Talking Points", "Attachments / Links", "Header-footer Branding", "Distribution Date" ], zh: [ "ÊñáÊ°£Á±ªÂûãÔºàËÆÆÁ®ã„ÄÅÁÆÄÊä•„ÄÅÊâãÂÜå„ÄÅÊîøÁ≠ñÁ≠âÔºâ", "ÁõÆÊ†áËØªËÄÖ", "ÈáçÁÇπÈÉ®ÂàÜ / Ë¶ÅÁÇπ", "ÈôÑ‰ª∂ / ÈìæÊé•", "È°µÁúâÈ°µËÑöÂìÅÁâåÊ†áËØÜ", "ÂèëÂ∏ÉÊó•Êúü" ], "zh-HK": [ "Êñá‰ª∂È°ûÂûãÔºàË≠∞Á®ã„ÄÅÁ∞°Â†±„ÄÅÊâãÂÜä„ÄÅÊîøÁ≠ñÁ≠âÔºâ", "ÁõÆÊ®ôËÆÄËÄÖ", "ÈáçÈªûÂÖßÂÆπ / Ë®éË´ñË¶ÅÈªû", "ÈôÑ‰ª∂ / ÈèàÁµê", "È†ÅÈ¶ñÈ†ÅÂ∞æÂìÅÁâåÊ®ôË™å", "ÁôºÂ∏ÉÊó•Êúü" ] }
    };
    
    const topicTemplates = {
        "Lesson Plan": "Please generate a detailed Lesson Plan using the following template:\n‚Ä¢ Lesson Title / Subject Area\n‚Ä¢ Learning Goals & Measurable Objectives\n‚Ä¢ Prerequisite Knowledge\n‚Ä¢ Materials / Resources List\n‚Ä¢ Step‚Äëby‚Äëstep Procedure & Timing\n‚Ä¢ Assessment / Evidence of Learning\n‚Ä¢ Differentiation / Accommodations\n‚Ä¢ Anticipated Difficulties/ Challenges ‚Üí Solution\n‚Ä¢ Follow‚Äëup / Reflection box",
        "Class Materials (PPT/pictures)": "Please generate detailed Class Materials based on this template:\n‚Ä¢ Presentation Topic / Focus Question\n‚Ä¢ Expected Audience (Grade or Course)\n‚Ä¢ Key Points / Slide Outline\n‚Ä¢ Desired Visual Assets (images, charts, video links)\n‚Ä¢ Desired Audio Assets (music, sound clips)\n‚Ä¢ Branding Elements (school logo, colors, fonts)\n‚Ä¢ Speaker‚Äënote Depth (none / bullet / full script)\nList each slide and suggest a relevant explanatory image for each to help student comprehension.",
        "Report Card": "Please generate a detailed Report Card using this template:\n‚Ä¢ Student & Class Identifiers\n‚Ä¢ Term / Grading Period\n‚Ä¢ Subject List & Grade Scale\n‚Ä¢ Attendance Figures\n‚Ä¢ Behavior /Work‚ÄëHabit Ratings\n‚Ä¢ Other Learning Experience/ Extra-curricular activities\n‚Ä¢ Award\n‚Ä¢ Teacher Narrative Comments\n‚Ä¢ Parent signature flag",
        "Student-Work Feedback": "Please generate detailed Student Work Feedback using this template:\n‚Ä¢ Student / Assignment ID\n‚Ä¢ Rubric criteria or \"Glow & Grow\" fields (Strengths, Needs, Next Steps)\n‚Ä¢ Performance level or score\n‚Ä¢ Inline examples / Quotes\n‚Ä¢ Overall Comment\n‚Ä¢ Next-check-in Date",
        "Subject Question Bank / Assignment": "Please generate a Subject Question Bank / Assignment using this template:\n‚Ä¢ Subject & Topic Tags\n‚Ä¢ Standard Alignment\n‚Ä¢ Question Type (MCQ, open, etc.)\n‚Ä¢ Difficulty Level\n‚Ä¢ Question Text\n‚Ä¢ Answer Choices & Correct Answer\n‚Ä¢ Explanation / Feedback\n‚Ä¢ Time Limit Per Item\n‚Ä¢ Category Folder",
        "Activity Plan / Extracurricular": "Please generate a detailed Activity Plan using this template:\n‚Ä¢ Activity Name & Purpose\n‚Ä¢ Date(s) / Time block\n‚Ä¢ Location & Access notes\n‚Ä¢ Target Group / # Students\n‚Ä¢ Required materials & Equipment\n‚Ä¢ Action plan\n‚Ä¢ Roles & supervision: resources allocation/ responsibilities\n‚Ä¢ Risk / safety considerations\n‚Ä¢ Assessment or reflection Method",
        "Admin Helper (PPT / Word)": "Please generate an Admin Helper document using this template:\n‚Ä¢ Document Type (agenda, newsletter, handbook, policy)\n‚Ä¢ Audience\n‚Ä¢ Key Sections / Talking Points\n‚Ä¢ Attachments / Links\n‚Ä¢ Header-footer Branding\n‚Ä¢ Distribution Date"
    };

    // --- Utility Functions ---
    const t = (key, vars = {}) => {
        let s = translations[currentLang]?.[key] || translations.eng[key] || key;
        for (const [k, v] of Object.entries(vars)) s = s.replace(`{${k}}`, v);
        return s;
    };

    const trType = (opt) => {
        const key = `type_${opt.toLowerCase().replace(/[^a-z]/g, '_').replace(/_{2,}/g, '_').replace(/_$/, '')}`;
        const mapping = {
            'type_lesson_plan': 'type_lesson',
            'type_class_materials_ppt_pictures_': 'type_materials',
            'type_report_card': 'type_report',
            'type_student_work_feedback': 'type_feedback',
            'type_subject_question_bank_assignment': 'type_bank',
            'type_activity_plan_extracurricular': 'type_activity',
            'type_admin_helper_ppt_word_': 'type_admin'
        };
        return t(mapping[key] || opt);
    };

    // --- UI Update Functions ---
    function updateUIText() {
        document.querySelector('h2.centered-heading').textContent = t('title');
        document.querySelector('.next-button').textContent = t('next');
        document.querySelector('.tooltip-text').textContent = t('upload');
        document.getElementById('user-input').placeholder = t('ph_input');
        
        // Update stage prompts already in the chat
        document.querySelectorAll('[data-stage-index] .bubble').forEach(b => {
            const idx = Number(b.parentElement.dataset.stageIndex);
            const isBot = b.parentElement.classList.contains('bot');
            if (isBot && !isNaN(idx) && idx < stages.length) {
                b.textContent = t(stages[idx].promptKey);
            }
        });

        // Update Stage 3 UI specifically
        document.getElementById('question3-title').textContent = t('question3');
        document.getElementById('db-browser-label').textContent = t('browseFiles');
        const [uploadBtn, browseBtn] = document.querySelectorAll('#stage-3-ui .choice-btn');
        if (uploadBtn) uploadBtn.textContent = t('uploadFiles');
        if (browseBtn) browseBtn.textContent = t('browseDatabase');
    }

    function refreshStage0UI() {
        const promptBubble = document.querySelector('[data-stage-index="0"].bot .bubble');
        if (promptBubble) promptBubble.textContent = t('question1');
        document.querySelectorAll('button[data-opt-key]').forEach(btn => {
            btn.textContent = trType(btn.dataset.optKey);
        });
    }

    // --- Core UI Logic ---
    function appendMessage(content, sender, stageIndex = null, asMarkdown = false) {
      content = content || '';
      const container = document.createElement('div');
      container.className = `message ${sender}`;
      if (stageIndex !== null) container.dataset.stageIndex = stageIndex;

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.textContent = sender === 'bot' ? 'ü§ñ' : 'üßë‚Äçüè´';

      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      if (asMarkdown) {
        renderMarkdown(bubble, content);
      } else {
        bubble.textContent = content;
      }

      container.append(avatar, bubble);
      chat.appendChild(container);
      chat.scrollTop = chat.scrollHeight;
      return container;
    }

    function renderMarkdown(bubble, md) {
      md = (md || '').trim().replace(/^```(markdown)?\n?/i, '').replace(/```$/, '');
      bubble.innerHTML = DOMPurify.sanitize(marked.parse(md));
      bubble.querySelectorAll('a').forEach(a => {
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
      });
    }

    // --- Main Conversational Flow (Stages) ---
    function showStage() {
        if (currentStage >= stages.length) {
            generateContent();
            return;
        }

        const stage = stages[currentStage];
        const promptTxt = t(stage.promptKey);
        
        // Hide all special UI sections by default
        document.getElementById('stage-3-ui').style.display = 'none';
        inputArea.style.display = 'flex';

        if (stage.key === 'have') {
            appendMessage(promptTxt, 'bot', currentStage);
            document.getElementById('stage-3-ui').style.display = 'block';
            inputArea.style.display = 'none'; // Hide main input area during this stage
            showUploadSection(); // Default to upload view
            return; // Stop further execution, wait for user action in Stage 3 UI
        }

        if (stage.type === 'dropdown') {
            appendMessage(promptTxt, 'bot', currentStage);
            const container = document.createElement('div');
            container.className = 'message bot';
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.textContent = 'ü§ñ';
            const btnGroup = document.createElement('div');
            Object.assign(btnGroup.style, { display: 'flex', flexDirection: 'column', gap: '8px', marginLeft: '44px' });

            stage.options.forEach(optConst => {
                const btn = document.createElement('button');
                btn.dataset.optKey = optConst;
                btn.textContent = trType(optConst);
                Object.assign(btn.style, { padding: '10px 16px', border: '1px solid #ccc', borderRadius: '6px', background: 'white', cursor: 'pointer', fontFamily: 'Inter', transition: '0.2s' });
                btn.onclick = () => handleChooseType(btn, optConst);
                btnGroup.appendChild(btn);
            });

            container.append(avatar, btnGroup);
            chat.appendChild(container);
        } else if (stage.type === 'yesno') {
            // This logic is now part of askIfRefineNeeded
            return; 
        } else if (stage.key === 'more') {
            renderMoreForm();
        } else {
            appendMessage(promptTxt, 'bot', currentStage);
        }
        chat.scrollTop = chat.scrollHeight;
    }

    function handleUserInput() {
        const stage = stages[currentStage];
        if (!stage) return;
        const value = input.value.trim();
        
        if (!value) return; // Only process if there is text input
        
        answers[stage.key] = value;
        appendMessage(value, 'user', currentStage);
        input.value = '';
        
        currentStage++;
        showStage();
    }
    
    function handleChooseType(btn, optConst) {
        const stageKey = 'type';
        const oldChoice = answers[stageKey];
        const newLabel = trType(optConst);

        if (oldChoice && oldChoice !== optConst) {
            if (!confirm(`${t('replaceConfirm', { filename: oldChoice })}\n‚Üí ${newLabel}`)) return;
        }

        // Reset all buttons and messages after this point
        pruneMessagesAfterStage(-1); // Clear everything after greeting
        showStage(); // Restart from Stage 0 UI
        
        // Now apply selection
        const newBtnGroup = chat.lastChild;
        const buttons = newBtnGroup.querySelectorAll('button');
        buttons.forEach(b => b.classList.remove('selected'));
        const targetBtn = Array.from(buttons).find(b => b.dataset.optKey === optConst);
        if(targetBtn) targetBtn.classList.add('selected');

        answers[stageKey] = optConst;
        appendMessage(newLabel, 'user', 0);
        
        currentStage = 1;
        showStage();
    }

    function pruneMessagesAfterStage(stageIdx) {
        // Remove answers from state
        for (let i = stageIdx + 1; i < stages.length; i++) {
            delete answers[stages[i].key];
        }
        if (stageIdx < 2) delete answers.have; // specifically clear 'have' if going back before it

        // Remove messages from UI
        const messages = Array.from(document.querySelectorAll('#chat .message'));
        for (let i = messages.length - 1; i >= 0; i--) {
            const el = messages[i];
            const idx = parseInt(el.dataset.stageIndex, 10);
            if (!isNaN(idx) && idx > stageIdx) {
                el.remove();
            }
        }
        
        // Also remove non-stage-indexed messages that appear after the prune point
        const allChatChildren = Array.from(chat.children);
        const lastMessageToKeep = Array.from(allChatChildren).reverse().find(el => {
            const idx = parseInt(el.dataset.stageIndex, 10);
            return !isNaN(idx) && idx <= stageIdx;
        });

        if (lastMessageToKeep) {
            let nextEl = lastMessageToKeep.nextSibling;
            while(nextEl) {
                const toRemove = nextEl;
                nextEl = nextEl.nextSibling;
                toRemove.remove();
            }
        } else { // If nothing to keep (e.g., pruning after stage -1)
             const heading = chat.querySelector('h2');
             chat.innerHTML = '';
             if(heading) chat.appendChild(heading);
        }

        // Clean up UI state
        cleanupRefineUI();
        lastGeneratedForm?.remove();
        lastUserMoreMessage?.remove();
        document.getElementById('stage-3-ui').style.display = 'none';
        inputArea.style.display = 'flex';
    }


    // --- Stage 3: File Input (Upload/Browse) ---
    function showUploadSection() {
        document.querySelectorAll('#stage-3-ui .choice-btn').forEach(btn => btn.classList.remove('selected'));
        document.querySelector('#stage-3-ui .choice-btn:first-child').classList.add('selected');
        document.getElementById('upload-section').style.display = 'block';
        document.getElementById('db-browser-container').style.display = 'none';
    }

    function showDatabaseSection() {
        document.querySelectorAll('#stage-3-ui .choice-btn').forEach(btn => btn.classList.remove('selected'));
        document.querySelector('#stage-3-ui .choice-btn:last-child').classList.add('selected');
        document.getElementById('upload-section').style.display = 'none';
        document.getElementById('db-browser-container').style.display = 'block';
        if (typeof books !== 'undefined') renderGroupedList(books);
    }
    
    function handleStage3FileUpload(fileList) {
        if (!fileList.length) return;
        
        const fileNames = Array.from(fileList).map(f => {
            const fileRecord = { id: crypto.randomUUID(), name: f.name, note: '', text: '', source: 'upload' };
            if (!answers.have) answers.have = [];
            answers.have.push(fileRecord);
            extractAndStore(fileRecord, f); // Use streaming extraction
            return `üìé ${f.name}`;
        }).join('\n');
        
        appendMessage(fileNames, 'user', currentStage);

        document.getElementById('stage-3-ui').style.display = 'none';
        inputArea.style.display = 'flex';
        currentStage++;
        showStage();
    }

    function handleDatabaseFileSelection(fileId, title) {
        const fileEntry = { id: fileId, name: title, source: 'database', url: `https://drive.google.com/file/d/${fileId}/view`, text: `Database file reference: ${title}` };
        if (!answers.have) answers.have = [];
        answers.have.push(fileEntry);

        const fileMessage = `Selected from database: <a href="${fileEntry.url}" class="uploaded-file" target="_blank">üìö ${title}</a>`;
        appendMessage(fileMessage, 'user', currentStage, true);
        
        document.getElementById('stage-3-ui').style.display = 'none';
        inputArea.style.display = 'flex';
        currentStage++;
        showStage();
    }

    // --- Database Browser UI ---
    function renderGroupedList(bookList) {
        const container = document.getElementById('item-list');
        container.innerHTML = '';
        const groupMap = {};
        bookList.forEach(book => {
            const group = book.path || 'Uncategorized';
            if (!groupMap[group]) groupMap[group] = [];
            groupMap[group].push(book);
        });

        Object.keys(groupMap).sort().forEach(group => {
            const titleEl = document.createElement('div');
            titleEl.className = 'group-title';
            titleEl.textContent = `üìÇ ${group}`;
            container.appendChild(titleEl);

            groupMap[group].sort((a, b) => a.title.localeCompare(b.title)).forEach(book => {
                const div = document.createElement('div');
                div.className = 'book-item';
                div.textContent = book.title;
                const fileId = extractFileId(book.drive_url);
                if(fileId) div.onclick = () => onItemClick(div, fileId, book.title);
                container.appendChild(div);
            });
        });
    }

    function extractFileId(driveUrl) {
        const m = (driveUrl || '').match(/\/d\/([^/]+)\//);
        return m ? m[1] : '';
    }

    function onItemClick(divEl, fileId, title) {
        document.querySelectorAll('.book-item').forEach(el => el.classList.remove('selected'));
        divEl.classList.add('selected');
        const pdfPreview = document.getElementById('pdf-preview');
        pdfPreview.style.display = 'block';
        const pdfContainer = document.getElementById('pdf-container');
        pdfContainer.innerHTML = `<iframe src="https://drive.google.com/file/d/${fileId}/preview" style="width:100%; height:100%; border:none;"></iframe>`;
        
        const confirmBtn = document.getElementById('confirm-selection');
        const newConfirmBtn = confirmBtn.cloneNode(true); // To remove old listeners
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        newConfirmBtn.textContent = t('confirmSelection');
        newConfirmBtn.onclick = () => handleDatabaseFileSelection(fileId, title);
    }

    // --- Stage 4: More Details Form ---
    function renderMoreForm() {
        lastGeneratedForm?.remove();
        lastUserMoreMessage?.remove();

        const container = appendMessage('', 'bot', currentStage);
        const bubble = container.querySelector('.bubble');
        bubble.innerHTML = ''; // Clear default content

        const promptText = document.createElement('div');
        promptText.textContent = t('morePrompt');
        promptText.style.marginBottom = '8px';

        const form = document.createElement('div');
        Object.assign(form.style, { display: 'flex', flexDirection: 'column', gap: '8px' });
        
        const inputs = {
            prompt: makeInput(t('ph_comment')),
            grade: makeInput(t('ph_grade')),
            students: makeInput(t('ph_students')),
            duration: makeInput(t('ph_duration')),
            length: makeInput(t('ph_length')),
        };

        Object.values(inputs).forEach(inp => form.appendChild(inp));

        const submitBtn = document.createElement('button');
        submitBtn.textContent = t('saveBtn');
        Object.assign(submitBtn.style, { marginTop: '6px', padding: '6px 12px', background: '#10a37f', color: '#fff', border: 'none', borderRadius: '6px', cursor: 'pointer' });
        submitBtn.onclick = () => {
            const moreData = {
                prompt: inputs.prompt.value.trim(),
                grade: inputs.grade.value.trim(),
                students: inputs.students.value.trim(),
                duration: inputs.duration.value.trim(),
                length: inputs.length.value.trim(),
            };

            if (Object.values(moreData).every(v => !v)) {
                alert(t('pleaseFill'));
                return;
            }

            answers['more'] = moreData;
            const na = t('na');
            const userInfo = `
                üìå ${t('details')}:
                - **${t('label_comment')}**: ${moreData.prompt || na}
                - **${t('label_grade')}**: ${moreData.grade || na}
                - **${t('label_students')}**: ${moreData.students || na}
                - **${t('label_duration')}**: ${moreData.duration || na}
                - **${t('label_length')}**: ${moreData.length || na}
            `.trim();
            
            container.remove(); // Remove the form
            lastUserMoreMessage = appendMessage(userInfo, 'user', currentStage, true);
            
            currentStage++;
            generateContent();
        };

        form.appendChild(submitBtn);
        bubble.append(promptText, form);
        lastGeneratedForm = container;
        chat.scrollTop = chat.scrollHeight;

        function makeInput(placeholder) {
            const inp = document.createElement('input');
            inp.placeholder = placeholder;
            Object.assign(inp.style, { padding: '6px', border: '1px solid #ccc', borderRadius: '6px', fontFamily: 'Inter' });
            return inp;
        }
    }


    // --- File Extraction (Streaming version from 'previous') ---
    async function* extractTextFromFile(file, options = {}) {
        if (!file || !file.name) {
            yield `‚ö†Ô∏è Invalid file object provided.\n`;
            return;
        }
        const name = file.name.toLowerCase();

        if (name.endsWith('.pdf')) {
            yield* extractTextFromPDF(file, options);
        } else if (name.endsWith('.docx')) {
            yield* extractTextFromDocx(file);
        } else if (/\.(png|jpg|jpeg)$/i.test(name)) {
            yield* extractTextFromImage(file, { logger: options.tesseractLogger });
        } else {
            yield `‚ö†Ô∏è Unsupported file type: ${file.name}\n`;
        }
    }

    async function* extractTextFromDocx(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const { value } = await mammoth.extractRawText({ arrayBuffer });
            const paragraphs = value.split(/\n\s*\n/);
            for (const paragraph of paragraphs) {
                const trimmedParagraph = paragraph.trim();
                if (trimmedParagraph) {
                    yield trimmedParagraph + '\n';
                }
            }
        } catch (error) {
            console.error("Error extracting text from DOCX:", error);
            yield `‚ö†Ô∏è Error extracting text from ${file.name}: ${error.message}\n`;
        }
    }

    async function* extractTextFromImage(file, options = {}) {
        try {
            const tesseractOptions = { logger: options.logger || (m => console.log(`Tesseract (${file.name}): ${m.status} (${(m.progress * 100).toFixed(2)}%)`)) };
            const { data: { text } } = await Tesseract.recognize(file, 'chi_sim+chi_tra+eng', tesseractOptions);
            const lines = text.split('\n');
            for (const line of lines) {
                yield line + '\n';
            }
        } catch (error) {
            console.error("Error extracting text from image:", error);
            yield `‚ö†Ô∏è Error extracting text from ${file.name} (OCR): ${error.message}\n`;
        }
    }

    async function* extractTextFromPDF(file, options = {}) {
        let arrayBuffer;
        try {
            arrayBuffer = await file.arrayBuffer();
        } catch (readError) {
            yield `‚ö†Ô∏è Error reading file ${file.name}: ${readError.message}\n`;
            return;
        }

        let anyTextYieldedFromLayer = false;
        try {
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer.slice(0) }).promise;
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                if (content.items.length > 0) {
                    const pageText = content.items.map(item => item.str).join(' ');
                    const trimmedPageText = pageText.trim();
                    if (trimmedPageText) {
                        yield trimmedPageText + '\n';
                        anyTextYieldedFromLayer = true;
                    }
                }
            }
        } catch (err) {
            console.warn(`Text layer extraction failed for ${file.name}: ${err.message}. Will attempt OCR.`);
        }

        if (!anyTextYieldedFromLayer) {
            console.warn(`No text found in text layer of ${file.name}. Attempting OCR.`);
            try {
                const pdfForOcr = await pdfjsLib.getDocument({ data: arrayBuffer.slice(0) }).promise;
                const numPagesToOcr = Math.min(pdfForOcr.numPages, 5);
                for (let i = 1; i <= numPagesToOcr; i++) {
                    const page = await pdfForOcr.getPage(i);
                    const viewport = page.getViewport({ scale: 2 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    await page.render({ canvasContext: context, viewport }).promise;
                    const { data } = await Tesseract.recognize(canvas, 'chi_sim+chi_tra+eng', { logger: options.tesseractLogger });
                    if (data.text) yield data.text.trim() + '\n';
                }
            } catch (ocrErr) {
                console.error(`OCR process failed for ${file.name}:`, ocrErr);
                yield `‚ö†Ô∏è OCR process for ${file.name} failed: ${ocrErr.message}\n`;
            }
        }
    }

    async function extractAndStore(fileRecord, file) {
        const extractionId = Symbol(`extraction-${file.name}`);
        pendingExtractions.add(extractionId);

        try {
            let accumulatedText = '';
            for await (const chunk of extractTextFromFile(file)) {
                accumulatedText += chunk;
            }
            fileRecord.text = accumulatedText.trim() || '(empty or no extractable text)';
        } catch (err) {
            console.error('Extraction error in extractAndStore for file:', file.name, '‚Üí', err);
            fileRecord.text = `‚ùå Failed: ${err.message || String(err)}`;
        } finally {
            pendingExtractions.delete(extractionId);
            console.log(`Extraction complete for ${file.name}. Text length: ${fileRecord.text.length}`);
        }
    }

    // --- Content Generation & AI Call (Streaming version from 'previous') ---
    async function callDeepSeek(promptText, onChunkReceived) {
        const postData = { promptText, locale: currentLang };
        let reader;
        let completeContent = '';
        let isCompletedSuccessfully = false;

        return new Promise(async (resolve, reject) => {
            try {
                const response = await fetch('https://backend.canpaniongroup.com/aigc/aio-generation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(postData),
                });
                if (!response.ok || !response.body) throw new Error(`Server error: ${response.status}`);
                
                reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                const processSseEvents = () => {
                    let eolIndex;
                    while ((eolIndex = buffer.indexOf('\n\n')) >= 0) {
                        const messageBlock = buffer.substring(0, eolIndex);
                        buffer = buffer.substring(eolIndex + 2);
                        try {
                            const lines = messageBlock.split('\n');
                            let eventType = 'message';
                            let eventDataString = '';
                            for (const line of lines) {
                                if (line.startsWith('event:')) eventType = line.substring(6).trim();
                                else if (line.startsWith('data:')) eventDataString += line.substring(5).trim();
                            }
                            const parsedData = JSON.parse(eventDataString);
                            if (eventType === 'message' && parsedData.content) {
                                completeContent += parsedData.content;
                                if (onChunkReceived) onChunkReceived(parsedData.content);
                            } else if (eventType === 'end' && parsedData.status === 'completed') {
                                isCompletedSuccessfully = true;
                                resolve(completeContent);
                                return true; // Stop reading
                            } else if (eventType === 'error') {
                                throw new Error(parsedData.error);
                            }
                        } catch (e) {
                            console.error('Error parsing SSE data:', e, "Raw block:", messageBlock);
                        }
                    }
                    return false; // Continue reading
                };

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        if (buffer.trim()) processSseEvents();
                        if (!isCompletedSuccessfully) {
                           if (completeContent) resolve(completeContent); // Resolve with what we have
                           else reject(new Error('Stream ended prematurely.'));
                        }
                        break;
                    }
                    buffer += decoder.decode(value, { stream: true });
                    if (processSseEvents()) break;
                }
            } catch (error) {
                console.error('Fetch or stream processing error:', error);
                reject(error);
            } finally {
                if (reader) reader.cancel().catch(e => console.warn("Error cancelling reader:", e));
            }
        });
    }
    
    async function generateContent() {
        await Promise.allSettled([...pendingExtractions]); // Wait for all file extractions
        
        const uploads = answers['have'] || [];
        const fileTexts = uploads
            .filter(f => f.source === 'upload')
            .map(f => (f.text ?? '').trim().slice(0, 8000)) // Limit token usage per file
            .filter(Boolean).join('\n\n---\n\n');
            
        const dbRefs = uploads
            .filter(f => f.source === 'database')
            .map(f => `‚Ä¢ ${f.name}`)
            .join('\n');

        const selectedType = answers['type'];
        const basePrompt = topicTemplates[selectedType] || '';
        if (!basePrompt) {
            alert(t('noTemplateFound'));
            return;
        }

        const more = answers['more'] || {};
        const na = t('na');
        const purpose = answers['why'] ? `- **Purpose / Rationale**: ${answers['why']}` : '';
        const extraDetails = `
            Context Information:
            ${purpose}
            - **${t('label_comment')}**: ${more.prompt || na}
            - **${t('label_grade')}**: ${more.grade || na}
            - **${t('label_students')}**: ${more.students || na}
            - **${t('label_duration')}**: ${more.duration || na}
            - **${t('label_length')}**: ${more.length || na}
        `.trim();
        
        const docSection = fileTexts ? `üìÑ Uploaded Document Content:\n\`\`\`\n${fileTexts}\n\`\`\`` : '';
        const dbSection = dbRefs ? `üìö Referenced Database Files:\n${dbRefs}` : '';

        const fullPrompt = [docSection, dbSection, extraDetails, basePrompt].filter(Boolean).join('\n\n');
        console.log('üìù Prompt sent to AI:\n', fullPrompt);

        const loadingMsg = appendMessage('', 'bot');
        const loadingBubble = loadingMsg.querySelector('.bubble');
        loadingBubble.innerHTML = `<img src="https://cdn.prod.website-files.com/67af0a7f5730375704f96216/682588f940a6776a7f6c138a_boywalkingg.gif" style="height:120px;vertical-align:middle;" alt="loading"><span>${t('pleaseWait')}</span>`;

        try {
            let tempResult = '';
            await callDeepSeek(fullPrompt, (chunk) => {
                tempResult += chunk;
                renderMarkdown(loadingBubble, tempResult);
            });
            fullMarkdown = tempResult; // Final complete markdown
            
            appendExportButton(fullMarkdown);
            askIfRefineNeeded();
        } catch (err) {
            console.error(err);
            loadingBubble.textContent = t('generationFailed');
        }
    }
    
    let exportCount = 0;
    function appendExportButton(markdownContent) {
        const exportMsg = appendMessage('', 'bot');
        const exportId = `exportbtn-${exportCount++}`;
        exportMsg.querySelector('.bubble').innerHTML = `<a id="${exportId}" href="#" style="text-decoration: none; color: #10a37f; font-weight: bold;">${t('exportDocx')}</a>`;
        document.getElementById(exportId).onclick = (e) => {
            e.preventDefault();
            const htmlContent = marked.parse(markdownContent);
            if (htmlContent && typeof htmlDocx !== 'undefined') {
                const docxBlob = htmlDocx.asBlob(htmlContent);
                saveAs(docxBlob, 'generated-plan.docx');
            } else {
                alert('No content to export or export library not found.');
            }
        };
    }
    
    // --- Refinement Logic ---
    function cleanupRefineUI() {
        Object.values(refineState).forEach(node => node?.remove());
        Object.keys(refineState).forEach(k => (refineState[k] = null));
    }
    
    function askIfRefineNeeded() {
        cleanupRefineUI();
        refineState.promptMsg = appendMessage(t('question5'), 'bot');
        const container = appendMessage('', 'bot');
        container.querySelector('.avatar').remove(); // No avatar for button group
        const btnGroup = container.querySelector('.bubble');
        btnGroup.style.background = 'none';
        btnGroup.style.padding = '0';
        btnGroup.style.marginLeft = '44px';
        btnGroup.innerHTML = '';
        
        ['yes', 'no'].forEach(key => {
            const btn = document.createElement('button');
            btn.textContent = t(key);
            Object.assign(btn.style, { padding: '8px 14px', borderRadius: '6px', background: 'white', border: '1px solid #ccc', cursor: 'pointer', marginRight: '10px' });
            btn.onclick = () => {
                btnGroup.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                refineState.userAnswerMsg?.remove();
                refineState.userAnswerMsg = appendMessage(key === 'yes' ? t('pleaseRefine') : t('noThanks'), 'user');
                
                if (key === 'yes') {
                    refineState.gotItMsg?.remove();
                    askRefineSections();
                } else {
                    refineState.optionsContainer?.remove();
                    refineState.botPromptMsg?.remove();
                    refineState.gotItMsg = appendMessage(t('done'), 'bot');
                }
            };
            btnGroup.appendChild(btn);
        });
        refineState.choiceContainer = container;
    }

    function askRefineSections() {
        refineState.optionsContainer?.remove();
        refineState.botPromptMsg?.remove();
        
        const type = answers['type'];
        const langKey = ['eng', 'zh', 'zh-HK'].find(k => k === currentLang) || 'eng';
        const fields = templateSections[type]?.[langKey];
        if (!fields?.length) return;

        refineState.botPromptMsg = appendMessage(t('refineWhich'), 'bot');
        const wrap = appendMessage('', 'bot');
        wrap.querySelector('.avatar').remove();
        const bubble = wrap.querySelector('.bubble');
        bubble.innerHTML = '';
        bubble.style.background = 'none';
        bubble.style.paddingLeft = '44px';

        const selected = new Set();
        fields.forEach(f => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.marginBottom = '6px';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.onchange = () => cb.checked ? selected.add(f) : selected.delete(f);
            label.append(cb, ` ${f}`);
            bubble.appendChild(label);
        });

        const okBtn = document.createElement('button');
        okBtn.textContent = t('regenerateBtn');
        Object.assign(okBtn.style, { marginTop: '10px', padding: '8px 14px', borderRadius: '6px', background: '#10a37f', color: 'white', border: 'none', cursor: 'pointer' });
        okBtn.onclick = async () => {
            if (!selected.size) {
                alert(t('atLeastOnePart'));
                return;
            }
            const partList = [...selected];
            appendMessage(`${t('pleaseRefine')}\n- ${partList.join('\n- ')}`, 'user', null, true);
            
            const loadingMsg = appendMessage('‚è≥ Regenerating‚Ä¶', 'bot');
            const prompt = `
                You are revising a teacher document.
                ### Previous draft (markdown)\n\`\`\`\n${fullMarkdown}\n\`\`\`
                ### Task\nRewrite ONLY the following section(s) with richer detail, leaving everything else unchanged:
                ${partList.map(p => '- ' + p).join('\n')}
                Return **only the rewritten sections** in markdown, starting with their original headings. **Do not include triple backticks (\`\`\`) in your response.**
            `;

            try {
                let refinedContent = '';
                await callDeepSeek(prompt, chunk => {
                    refinedContent += chunk;
                    renderMarkdown(loadingMsg.querySelector('.bubble'), refinedContent);
                });
                fullMarkdown = mergeSections(fullMarkdown, refinedContent);
                appendExportButton(fullMarkdown);
                askIfRefineNeeded();
            } catch (e) {
                loadingMsg.querySelector('.bubble').textContent = t('generationFailed');
            }
        };

        bubble.appendChild(okBtn);
        refineState.optionsContainer = wrap;
    }

    function mergeSections(oldDoc, patchDoc) {
        const blocks = patchDoc.split(/^(#+)\s+/m).slice(1); // Split by markdown headings
        for (let i = 0; i < blocks.length; i += 2) {
            const headingLevel = blocks[i];
            const headingAndBody = blocks[i + 1];
            const heading = headingAndBody.split('\n')[0].trim();
            const body = headingAndBody.substring(heading.length).trim();
            
            const hEsc = escapeRegExp(heading);
            const re = new RegExp(`^${headingLevel}\\s+${hEsc}[\\s\\S]*?(?=\\n${headingLevel}|$)`, 'm');
            
            const newSection = `${headingLevel} ${heading}\n${body}`;
            if (re.test(oldDoc)) {
                oldDoc = oldDoc.replace(re, newSection);
            } else {
                oldDoc += `\n\n${newSection}`;
            }
        }
        return oldDoc;
    }

    // --- Event Listeners ---
    langSelector.addEventListener('change', () => {
        currentLang = langSelector.value;
        updateUIText();
        refreshStage0UI();
    });

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleUserInput();
        }
    });
    
    // Generic file upload handler for the main input area's button
    fileInput.addEventListener('change', () => {
       if (currentStage === 2) {
            handleStage3FileUpload(fileInput.files);
       } else {
            // Handle general file drops if needed in other stages
            console.log("Files attached outside of stage 3:", fileInput.files);
       }
       fileInput.value = ''; // Reset input
    });
    
    // Drag and drop for the entire input area
    inputArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        inputArea.style.backgroundColor = '#f3fffa';
    });
    inputArea.addEventListener('dragleave', () => {
        inputArea.style.backgroundColor = '';
    });
    inputArea.addEventListener('drop', (e) => {
        e.preventDefault();
        inputArea.style.backgroundColor = '';
        if (currentStage === 2) {
            handleStage3FileUpload(e.dataTransfer.files);
        }
    });

    // --- Initialisation ---
    window.addEventListener('DOMContentLoaded', () => {
        updateUIText();
        showStage();
        if (typeof books !== 'undefined') {
            document.getElementById('filter-input').addEventListener('input', e => {
                const kw = e.target.value.trim().toLowerCase();
                const filtered = books.filter(b => b.title.toLowerCase().includes(kw) || b.path.toLowerCase().includes(kw));
                renderGroupedList(filtered);
            });
        } else {
             console.warn("books.js not loaded or 'books' array is not defined.");
        }
    });

  </script>
</body>
</html>
