<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Tool</title>
  <!-- Add Markdown rendering library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      max-width: 800px;
      margin: 20px auto;
      padding: 0 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f9fafb;
      color: #111827;
    }
    .control-group {
        margin: 20px 0;
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    label {
        font-weight: 500;
        color: #374151;
        font-size: 14px;
    }
    .language-select {
      position: relative;
      width: 250px;
    }
    .language-select select {
      width: 100%;
      padding: 10px 16px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      color: #333;
      font-size: 14px;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .language-select::after {
      content: "‚ñº";
      font-size: 12px;
      color: #6b7280;
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }
    .language-select select:hover {
      border-color: #9ca3af;
    }
    .language-select select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }
    h2 {
        color: #1f2937;
    }
    .mode-switch {
      margin: 20px 0;
      display: flex;
      gap: 10px;
      justify-content: space-between;
      flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
    }
    .mode-button {
      padding: 12px 24px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      cursor: pointer;
      background: white;
      color: #374151;
      transition: all 0.2s ease-in-out;
      font-size: 15px;
      font-weight: 500;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      flex-grow: 1;
      text-align: center;
    }
    .mode-button:hover {
      background: #f3f4f6;
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(0,0,0,0.08);
    }
    .mode-button.selected {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
      box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
    }
    #submitBtn {
      display: block;
      width: 100%;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #22c55e;
      color: white;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.2s ease-in-out;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    #submitBtn:hover {
      background: #16a34a;
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
    }
    #loading {
      display: none;
      color: #4b5563;
      margin: 15px 0;
      text-align: center;
    }
    .input-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    input[type="file"], input[type="url"] {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      box-sizing: border-box; /* Important */
    }
    .markdown-content {
      background: #ffffff;
      padding: 25px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      line-height: 1.7;
      font-size: 16px;
    }
    .result-header {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e5e7eb;
    }
    .result-header .emoji {
      font-size: 24px;
      margin-right: 12px;
    }
    .result-header .title {
      font-size: 18px;
      font-weight: 600;
      color: #111827;
    }
    .result-content {
      white-space: pre-wrap;
      color: #374151;
      word-wrap: break-word;
    }
    .button-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div class="control-group">
      <label id="videoLangLabel" for="videoLanguageSelect">Video Language</label>
      <div class="language-select">
          <select id="videoLanguageSelect">
              <option value="en-US">English (US)</option>
              <option value="zh-CN">ÁÆÄ‰Ωì‰∏≠Êñá (CN)</option>
              <option value="zh-HK">ÁπÅÈ´î‰∏≠Êñá (HK)</option>
              <option value="zh-TW">ÁπÅÈ´î‰∏≠Êñá (TW)</option>
          </select>
      </div>
  </div>


  <h2 id="title">üéôÔ∏è Upload Audio or üì∫ Paste Video Link</h2>

  <div class="input-group">
    <input type="file" id="media" accept="audio/*,video/*">
    <input type="url" id="videoLink" placeholder="Paste YouTube video link">
  </div>
  
  <div class="button-container">
    <div class="mode-switch">
      <button id="transcriptBtn" class="mode-button" onclick="switchMode('transcript')">üìù Show Full Text</button>
      <button id="summaryBtn" class="mode-button" onclick="switchMode('summary')">üßë‚Äçüè´ Generate Summary</button>
      <button id="minutesBtn" class="mode-button" onclick="switchMode('minutes')">üìù Minutes</button>
    </div>
    <button onclick="processMedia()" id="submitBtn">Submit</button>
  </div>
  
  <div id="loading">Processing...</div>

  <div id="out" class="markdown-content">
    <div class="result-header">
      <span class="emoji">üóíÔ∏è</span>
      <span class="title">Result</span>
    </div>
    <div class="result-content">Waiting for input...</div>
  </div>

  <script>
    // --- 1. CONFIGURATION ---
    const translations = {
      'en': { 
        title: 'üéôÔ∏è Upload Audio or üì∫ Paste Video Link', 
        videoLinkPlaceholder: 'or paste YouTube video link', 
        transcriptBtn: 'üìù Full Text', 
        summaryBtn: 'üßë‚Äçüè´ Brief Summary', 
        minutesBtn: 'üìù Minutes', 
        submitBtn: 'Submit', 
        loading: 'Processing...', 
        waiting: 'Waiting for input...', 
        noInput: 'Please upload an audio file or paste a video link!',
        noLang: 'Please select a video language!',
        processingError: 'Request failed: ', 
        error: 'Error: ', 
        videoLangLabel: 'Video Language',
        resultTitle: 'Result',
        fullTextTitle: 'Full Text'
      },
      'zh': { 
        title: 'üéôÔ∏è ‰∏ä‰º†Èü≥È¢ë Êàñ üì∫ Á≤òË¥¥ËßÜÈ¢ëÈìæÊé•', 
        videoLinkPlaceholder: 'ÊàñÁ≤òË¥¥ YouTube ËßÜÈ¢ëÈìæÊé•', 
        transcriptBtn: 'üìù ÂÖ®Êñá', 
        summaryBtn: 'üßë‚Äçüè´ ÊëòË¶Å', 
        minutesBtn: 'üìù ‰ºöËÆÆÁ∫™Ë¶Å', 
        submitBtn: 'Êèê‰∫§Â§ÑÁêÜ', 
        loading: 'Â§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂÄô...', 
        waiting: 'Á≠âÂæÖËæìÂÖ•...', 
        noInput: 'ËØ∑‰∏ä‰º†‰∏Ä‰∏™Èü≥È¢ëÊñá‰ª∂ÊàñÁ≤òË¥¥ËßÜÈ¢ëÈìæÊé•ÔºÅ',
        noLang: 'ËØ∑ÈÄâÊã©ËßÜÈ¢ëËØ≠Ë®ÄÔºÅ',
        processingError: 'ËØ∑Ê±ÇÂ§±Ë¥•Ôºö', 
        error: 'ÈîôËØØÔºö', 
        videoLangLabel: 'ËßÜÈ¢ëËØ≠Ë®Ä',
        resultTitle: 'ÁªìÊûú',
        fullTextTitle: 'ÂÖ®Êñá'
      },
      'zh-Hant': { 
        title: 'üéôÔ∏è ‰∏äÂÇ≥Èü≥È†ª Êàñ üì∫ Ë≤º‰∏äË¶ñÈ†ªÈÄ£Áµê', 
        videoLinkPlaceholder: 'ÊàñË≤º‰∏ä YouTube Ë¶ñÈ†ªÈÄ£Áµê', 
        transcriptBtn: 'üìù ÂÖ®Êñá', 
        summaryBtn: 'üßë‚Äçüè´ ÊëòË¶Å', 
        minutesBtn: 'üìù ÊúÉË≠∞Á¥ÄË¶Å', 
        submitBtn: 'Êèê‰∫§ËôïÁêÜ', 
        loading: 'ËôïÁêÜ‰∏≠ÔºåË´ãÁ®çÂÄô...', 
        waiting: 'Á≠âÂæÖËº∏ÂÖ•...', 
        noInput: 'Ë´ã‰∏äÂÇ≥‰∏ÄÂÄãÈü≥È†ªÊñá‰ª∂ÊàñË≤º‰∏äË¶ñÈ†ªÈÄ£ÁµêÔºÅ',
        noLang: 'Ë´ãÈÅ∏ÊìáË¶ñË®äË™ûË®ÄÔºÅ',
        processingError: 'Ë´ãÊ±ÇÂ§±ÊïóÔºö', 
        error: 'ÈåØË™§Ôºö',
        videoLangLabel: 'Ë¶ñË®äË™ûË®Ä',
        resultTitle: 'ÁµêÊûú',
        fullTextTitle: 'ÂÖ®Êñá'
      }
    };
    
    // Global state
    let uiLang = 'en'; // Default UI language
    const cachedData = { transcript: null, summary: null, minutes: null, currentMode: 'transcript' };

    // DOM Elements
    const transcriptBtn = document.getElementById('transcriptBtn');
    const summaryBtn = document.getElementById('summaryBtn');
    const minutesBtn = document.getElementById('minutesBtn');
    const modeButtons = [transcriptBtn, summaryBtn, minutesBtn];
    const loadingEl = document.getElementById('loading');
    const outDiv = document.getElementById('out');

    // --- 2. CORE FUNCTIONS ---

    /**
     * Sets the user interface language based on a language code.
     * @param {string} lang - The language code (e.g., 'en', 'zh').
     */
    function setUiLanguage(lang) {
      // Fallback logic: if a specific regional lang (e.g., zh-CN) isn't found, try the base (zh).
      const t = translations[lang] || translations[lang.split('-')[0]] || translations['en'];
      uiLang = lang; // Store the current UI language

      document.getElementById('title').textContent = t.title;
      document.getElementById('videoLink').placeholder = t.videoLinkPlaceholder;
      document.getElementById('videoLangLabel').textContent = t.videoLangLabel;
      transcriptBtn.textContent = t.transcriptBtn;
      summaryBtn.textContent = t.summaryBtn;
      minutesBtn.textContent = t.minutesBtn;
      document.getElementById('submitBtn').textContent = t.submitBtn;
      loadingEl.textContent = t.loading;
      
      const resultTitleEl = outDiv.querySelector('.title');
      if (resultTitleEl && resultTitleEl.textContent === (translations[uiLang]?.resultTitle || 'Result')) {
          resultTitleEl.textContent = t.resultTitle;
      }
      
      const resultContentEl = outDiv.querySelector('.result-content');
      if(resultContentEl && resultContentEl.textContent === (translations[uiLang]?.waiting || 'Waiting for input...')){
          resultContentEl.textContent = t.waiting;
      }
    }

    /**
     * Sets the active processing mode.
     * @param {string} mode - The mode to activate ('transcript', 'summary', 'minutes').
     */
    function setMode(mode) {
      cachedData.currentMode = mode;
      modeButtons.forEach(b => b.classList.remove('selected'));
      document.getElementById(`${mode}Btn`).classList.add('selected');
    }

    /**
     * Handles switching between processing modes and displays cached results if available.
     * @param {string} mode - The new mode to switch to.
     */
    function switchMode(mode) {
      setMode(mode);
      if (cachedData[mode]) {
        return displayResult(mode, cachedData[mode]);
      }
      // If we want a summary/minutes and already have a transcript, we can request it.
      if ((mode === 'summary' || mode === 'minutes') && cachedData.transcript) {
        return processMedia(); // Re-use processMedia logic which handles this case
      }
    }

    /**
     * [FIXED] Renders the result in the output container.
     * Correctly handles different data structures for transcript, summary, and minutes.
     * @param {string} mode - The mode of the content being displayed ('transcript', 'summary', 'minutes').
     * @param {object} data - The data object containing the result text.
     */
    function displayResult(mode, data) {
        const t = translations[uiLang] || translations['en'];
        let textToRender = '';

        if (!data) {
            textToRender = 'No content available.';
        } else if (mode === 'transcript') {
            // For transcript, the data object has a 'transcript' property which is a string.
            textToRender = data.transcript || 'No transcript available.';
        } else if (mode === 'summary' || mode === 'minutes') {
            // For summary/minutes, data can be the full response { summary: { en: '...' } }
            // or the cached data { en: '...' }.
            const contentObject = data[mode] || data; 
            if (typeof contentObject === 'object' && contentObject !== null) {
                // Select the text for the current UI language, with fallbacks.
                textToRender = contentObject[uiLang] || contentObject[uiLang.split('-')[0]] || contentObject['en'] || 'Content not available for the selected language.';
            } else if (typeof contentObject === 'string') {
                textToRender = contentObject; // Fallback if it's just a string for some reason
            } else {
                textToRender = 'No content available for this mode.';
            }
        }

        let title;
        let emoji;
        if (mode === 'transcript') {
            title = t.fullTextTitle;
            emoji = 'üìù';
        } else if (mode === 'summary') {
            title = t.summaryBtn.replace(/üßë‚Äçüè´/g, '').trim();
            emoji = 'üßë‚ÄçÔøΩ';
        } else if (mode === 'minutes') {
            title = t.minutesBtn.replace(/üìù/g, '').trim();
            emoji = 'üìù';
        }

        // Ensure textToRender is a string before parsing to prevent errors.
        if (typeof textToRender !== 'string') {
            console.error("Invalid data passed to displayResult. Expected string, got:", textToRender);
            textToRender = "Error: Invalid content format.";
        }
        
        const content = `<div class="result-header"><span class="emoji">${emoji}</span><span class="title">${title}</span></div>
                         <div class="result-content">${marked.parse(textToRender)}</div>`;
        outDiv.innerHTML = content;
    }

    /**
     * Makes a non-streaming request to the backend (e.g., for summary, minutes).
     * @param {object} params - Parameters for the request, e.g., { reuseId: '...' }.
     */
    async function requestFullBody(params) {
        const t = translations[uiLang] || translations['en'];
        loadingEl.style.display = 'block';
        outDiv.innerHTML = `<div class="result-content">${marked.parse(`‚è≥ ${t.loading}`)}</div>`;

        const form = new FormData();
        form.append('mode', cachedData.currentMode);
        form.append('language', document.getElementById('videoLanguageSelect').value);
        if (params.reuseId) {
            form.append('reuseId', params.reuseId);
        } else {
             const mediaFile = document.getElementById('media').files[0];
             const videoLink = document.getElementById('videoLink').value;
             mediaFile ? form.append('media', mediaFile) : form.append('videoUrl', videoLink);
        }
        
        try {
            const res = await fetch('https://backend.canpaniongroup.com/aigc/process-media', {
                method: 'POST',
                body: form
            }).then(r => r.json());

            if (res.error) throw new Error(res.error);
            
            // [FIXED] Update cache granularly
            if (res.transcript && !cachedData.transcript) {
                cachedData.transcript = { id: res.id, transcript: res.transcript, engine: res.engine };
            }
            if (res.summary) {
                cachedData.summary = res.summary;
            }
            if (res.minutes) {
                cachedData.minutes = res.minutes;
            }
            
            // Pass the full response object to displayResult
            displayResult(cachedData.currentMode, res);
        } catch (e) {
            outDiv.innerHTML = `<div class="result-content">${marked.parse(`‚ùå ${t.error}${e.message}`)}</div>`;
        } finally {
            loadingEl.style.display = 'none';
        }
    }

    /**
     * Main function to process media, handling streaming for transcripts.
     */
    async function processMedia() {
        const videoLang = document.getElementById('videoLanguageSelect').value;
        const mediaFile = document.getElementById('media').files[0];
        const videoLink = document.getElementById('videoLink').value;
        const t = translations[uiLang] || translations['en'];

        if (!videoLang) {
            alert(t.noLang);
            return;
        }
        if (!mediaFile && !videoLink) {
            alert(t.noInput);
            return;
        }

        // If we want a summary/minutes, use the non-streaming request.
        // It will either use a cached transcript ID or upload the file again.
        if (cachedData.currentMode !== 'transcript') {
            return requestFullBody({ reuseId: cachedData.transcript?.id });
        }
        
        // If transcript is already cached, just display it.
        if(cachedData.transcript){
            return displayResult('transcript', cachedData.transcript);
        }


        // --- Streaming Logic for new transcriptions ---
        loadingEl.style.display = 'block';
        const streamingTitle = t.fullTextTitle + " (Streaming)";
        outDiv.innerHTML = `<div class="result-header"><span class="emoji">üìù</span><span class="title">${streamingTitle}</span></div>
                              <div class="result-content" id="transcript-content"></div>
                              <div class="recognizing-text" id="recognizing-content"></div>`;
        const transcriptContentEl = document.getElementById('transcript-content');
        const recognizingContentEl = document.getElementById('recognizing-content');
        
        // Reset cache for a new run
        Object.keys(cachedData).forEach(key => {
            if(key !== 'currentMode') cachedData[key] = null;
        });
        let streamedTranscriptForDisplay = ""; 

        const form = new FormData();
        form.append('mode', 'transcript');
        form.append('language', videoLang);
        mediaFile ? form.append('media', mediaFile) : form.append('videoUrl', videoLink);

        try {
            const response = await fetch('https://backend.canpaniongroup.com/aigc/process-media', { method: 'POST', body: form });
            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`Server error: ${response.status} ${errText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let streamEnded = false;

            while (!streamEnded) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const sseMessages = buffer.split('\n\n');
                buffer = sseMessages.pop();

                for (const msg of sseMessages) {
                    if (msg.startsWith('data: ')) {
                        const jsonString = msg.substring(6);
                        if (!jsonString) continue;
                        try {
                            const data = JSON.parse(jsonString);
                            if (data.type === 'chunk') {
                                const p = document.createElement('p');
                                p.textContent = data.content;
                                transcriptContentEl.appendChild(p);
                                streamedTranscriptForDisplay += data.content + '\n\n';
                                recognizingContentEl.innerText = '';
                            } else if (data.type === 'recognizing') {
                                recognizingContentEl.innerText = data.content;
                            } else if (data.type === 'end') {
                                cachedData.transcript = { 
                                    id: data.id, 
                                    transcript: streamedTranscriptForDisplay.trim(),
                                    engine: data.engine 
                                };
                                displayResult('transcript', cachedData.transcript);
                                streamEnded = true;
                                break;
                            } else if (data.type === 'error') {
                                throw new Error(`Transcription service error: ${data.message}`);
                            }
                        } catch(e) {
                            console.error("Failed to parse SSE message chunk:", jsonString, e);
                        }
                    }
                }
            }
            
            if (!streamEnded) {
                throw new Error("Stream closed unexpectedly without a final 'end' event from the server.");
            }

        } catch (e) {
            outDiv.innerHTML += `<div class="result-content">${marked.parse(`‚ùå ${t.error}${e.message}`)}</div>`;
        } finally {
            loadingEl.style.display = 'none';
            if (recognizingContentEl) recognizingContentEl.innerText = '';
        }
    }

    // --- 3. INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Determine UI language from the <html> tag's lang attribute
        const initialLang = document.documentElement.lang || 'en';
        setUiLanguage(initialLang);

        // Set default values
        document.getElementById('videoLanguageSelect').value = 'en-US';
        setMode('transcript');
    });
  </script>
</body>
</html>
