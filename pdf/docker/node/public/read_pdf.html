<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>PDF å…¨æ–‡ä¸ç›®å½•æå–ï¼ˆå‡çº§ç‰ˆï¼‰</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;padding:24px;max-width:940px;margin:auto;}
    h2{margin:0 0 12px;} #log{color:#888;margin:6px 0;}
    textarea{width:100%;height:420px;margin-top:18px;font-family:monospace;white-space:pre-wrap;}
    button{margin-right:8px;padding:8px 12px;background:#007cba;color:white;border:none;border-radius:4px;cursor:pointer;}
    button:hover{background:#005a87;} button:disabled{background:#ccc;cursor:not-allowed;}
    ul{padding-left:0;margin:14px 0;list-style:none;}
    li{margin:4px 0;padding:6px 8px;background:#f5f5f5;border-radius:4px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;}
    li:hover{background:#e0e0e0;}
    .toc-page{color:#007cba;font-weight:bold;}
    .toc-title{color:#333;font-weight:500;}
    #tocBox{border:1px solid #ddd;border-radius:6px;padding:16px;margin:16px 0;background:#fafafa;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
</head>
<body>
  <h2>ğŸ“„ PDF å…¨æ–‡ä¸ç›®å½•æå–åŠ©æ‰‹ï¼ˆå‡çº§ç‰ˆï¼‰</h2>
  <p style="color:#666;">æ–°å¢æ™ºèƒ½é˜ˆå€¼ OCR å’Œäº‘ç«¯ MonkeyOCR å›é€€</p>

  <input type="file" id="pdfFile" accept="application/pdf"><br><br>
  <button id="extractTxtBtn">ğŸ“– æå–å…¨æ–‡</button>
  <button id="downloadBtn" disabled>ğŸ’¾ ä¸‹è½½ TXT</button><br><br>

  <button id="extractTocBtn">ğŸ“‘ æå–ç›®å½•ï¼ˆå¤šé¡µï¼‰</button>
  <label>ç›®å½•èµ·å§‹é¡µ:</label><input type="number" id="tocStartInput" placeholder="å¦‚ 5" min="1" style="width:60px;padding:6px;">
  <label style="margin-left:10px;">ç›®å½•ç»“æŸé¡µ:</label><input type="number" id="tocEndInput" placeholder="å¦‚ 6" min="1" style="width:60px;padding:6px;"><br><br>

  <label>é¡µç åç§»:</label><input type="number" id="pageOffsetInput" placeholder="å¦‚ 5" style="width:60px;padding:6px;">
  <label style="margin-left:10px;">é¢å¤–é¡µæ•°:</label><input type="number" id="extraPagesInput" placeholder="å¦‚ 5" style="width:60px;padding:6px;"><br><br>

  <div id="tocBox" style="display:none;"></div>
  <span id="log"></span>
  <textarea id="output" placeholder="è¾“å‡ºç»“æœå°†æ˜¾ç¤ºåœ¨æ­¤â€¦"></textarea>

  <script>
    const $ = s => document.querySelector(s);
    const log = t => $('#log').textContent = t;

    // 1) åˆå§‹åŒ– Tesseract Worker
    async function initWorker() {
      const w = await Tesseract.createWorker();
      await w.load(); 
      await w.loadLanguage('chi_sim'); 
      await w.initialize('chi_sim');
      return w;
    }

    // 2) è°ƒç”¨åç«¯ MonkeyOCR+BLIP æœåŠ¡
    async function proxyOcr(page) {
      const vp = page.getViewport({ scale: 3 });
      const canvas = document.createElement('canvas');
      canvas.width = vp.width; 
      canvas.height = vp.height;
      await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
      const dataUrl = canvas.toDataURL('image/png');

      const res = await fetch('http://localhost:7860/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ img_b64: dataUrl })
      });

      if (!res.ok) throw new Error(`OCR æœåŠ¡å‡ºé”™ï¼š${res.status}`);
      const { text } = await res.json();
      return text;
    }

    // 3) Tesseract å›é€€ + æœ€ç»ˆ BLIP
    async function ocrFallback(page, worker) {
      const vp = page.getViewport({ scale: 3 });
      const canvas = document.createElement('canvas');
      canvas.width = vp.width; 
      canvas.height = vp.height;
      await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
      const { data: { text: ocrText } } = await worker.recognize(canvas);
      if (ocrText.trim().length >= 20) {
        return ocrText;
      }
      return await proxyOcr(page);
    }

    // 4) æ ¹æ®æ–‡å­—å—æ•°é‡åŠå†…å®¹åˆ¤æ–­ï¼Œçº¯å›¾é¡µç›´æ¥èµ° proxyOcrï¼Œå…¶å®ƒé¡µèµ°æ–‡æœ¬åˆå¹¶ + å›é€€
    async function pageToText(page, worker) {
      const txtContent = await page.getTextContent({ normalizeWhitespace: true });
      // çº¯å›¾é¡µï¼ˆæ–‡å­—å—å¤ªå°‘ï¼‰
      if (txtContent.items.length < 10) {
        return await proxyOcr(page);
      }
      // æ–‡æœ¬åˆå¹¶
      const buckets = {};
      txtContent.items.forEach(item => {
        const y = Math.round(item.transform[5]);
        (buckets[y] || (buckets[y] = [])).push(item);
      });
      const lines = Object.keys(buckets)
        .sort((a,b)=>b-a)
        .map(y => buckets[y]
          .sort((i,j)=>i.transform[4]-j.transform[4])
          .map(i=>i.str).join('').trim()
        );
      const text = lines.join('\n').trim();

      // æ–‡æœ¬å¤ªå°‘æˆ–ä¸­æ–‡å°‘æ—¶ï¼ŒTesseract å›é€€
      const chineseCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
      if (chineseCount < 10 || text.length < 50) {
        const tesseractText = await ocrFallback(page, worker);
        return tesseractText;
      }

      return text;
    }

    // æå–æŒ‡å®šé¡µèŒƒå›´
    async function extractRange(start, end) {
      if (!window._lastPdf) return alert('è¯·å…ˆåŠ è½½ PDF å¹¶æå–ç›®å½•');
      log(`â³ æå–ç¬¬ ${start} åˆ° ${end} é¡µâ€¦`);
      $('#output').value = '';
      const pdf = window._lastPdf;
      const worker = await initWorker();
      let result = '';
      for (let p = start; p <= end && p <= pdf.numPages; p++) {
        const pg = await pdf.getPage(p);
        const txt = await pageToText(pg, worker);
        result += `---- Page ${p} ----\n${txt.trim()}\n\n`;
      }
      await worker.terminate();
      $('#output').value = result.trim();
      log(`âœ… å®Œæˆï¼šç¬¬ ${start}-${end} é¡µ`);
    }

    // å…¨æ–‡æå–
    $('#extractTxtBtn').onclick = async () => {
      const file = $('#pdfFile').files[0];
      if (!file) return alert('è¯·é€‰æ‹© PDF æ–‡ä»¶');
      log('â³ æå–å…¨æ–‡â€¦');
      $('#output').value = '';
      $('#downloadBtn').disabled = true;

      const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
      window._lastPdf = pdf;
      window._lastPdfPages = pdf.numPages;
      const worker = await initWorker();
      let full = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        log(`ğŸ“– ç¬¬ ${i}/${pdf.numPages} é¡µâ€¦`);
        const pg = await pdf.getPage(i);
        const txt = await pageToText(pg, worker);
        full += `---- Page ${i} ----\n${txt.trim()}\n\n`;
      }
      await worker.terminate();

      $('#output').value = full.trim();
      $('#downloadBtn').disabled = false;
      $('#downloadBtn').onclick = () => {
        const blob = new Blob([full], { type:'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = file.name.replace(/\.pdf$/i, '') + '.txt';
        a.click();
      };
      log(`âœ… å…¨æ–‡æå–å®Œæ¯•ï¼Œå…± ${pdf.numPages} é¡µ`);
    };

    // ç›®å½•æå–
    $('#extractTocBtn').onclick = async () => {
      const file = $('#pdfFile').files[0];
      if (!file) return alert('è¯·é€‰æ‹© PDF æ–‡ä»¶');
      const start = +$('#tocStartInput').value || 1;
      const end   = +$('#tocEndInput').value || start;
      log(`â³ æå–ç›®å½•ï¼šç¬¬ ${start} åˆ° ${end} é¡µâ€¦`);
      const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
      window._lastPdf = pdf;
      window._lastPdfPages = pdf.numPages;
      if (start < 1 || start > pdf.numPages || end < start) {
        return alert('ç›®å½•é¡µèŒƒå›´é”™è¯¯');
      }
      const worker = await initWorker();
      let combined = '';
      for (let p = start; p <= end; p++) {
        const pg = await pdf.getPage(p);
        combined += await pageToText(pg, worker) + '\n';
      }
      await worker.terminate();
      const tocList = extractToc(combined);
      renderToc(tocList);
    };

    // è§£æç›®å½•æ–‡æœ¬ä¸ºæ¡ç›®
    function extractToc(text) {
      const lines = text.split('\n').map(l=>l.trim())
        .filter(l=> l && !/^----/.test(l) && l!=='ç›®å½•' && !/^[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+$/.test(l));
      const toc = [], used = new Set();
      for (let i = 0; i < lines.length; i++) {
        if (used.has(i)) continue;
        const line = lines[i], next = lines[i+1] || '';
        let m = line.match(/^(.+?)\s+(\d{1,3})$/);
        if (m) {
          toc.push({ title: m[1], page: +m[2] });
          used.add(i);
          continue;
        }
        if (/^\d+$/.test(line) && next && !/^\d+$/.test(next)) {
          toc.push({ title: next, page: +line });
          used.add(i); used.add(i+1); i++;
          continue;
        }
        if (!/^\d+$/.test(line) && /^\d+$/.test(next)) {
          toc.push({ title: line, page: +next });
          used.add(i); used.add(i+1); i++;
          continue;
        }
      }
      return toc.sort((a,b)=>a.page - b.page);
    }

    // æ¸²æŸ“ç›®å½•åˆ—è¡¨
    function renderToc(list) {
      window._tocList = list;
      const box = $('#tocBox');
      box.style.display = 'block';
      box.innerHTML = '';
      if (!list.length) {
        box.innerHTML = '<div style="color:#e74c3c;text-align:center;">âŒ æœªæ£€æµ‹åˆ°ç›®å½•</div>';
        return;
      }
      const ul = document.createElement('ul');
      list.forEach(({ title, page }, idx) => {
        const li = document.createElement('li');
        li.innerHTML = `<span class="toc-title">${title}</span><span class="toc-page">${page}</span>`;
        li.onclick = () => handleRangeClick(idx);
        ul.appendChild(li);
      });
      box.appendChild(ul);
      log(`âœ… æå–åˆ° ${list.length} æ¡ç›®å½•`);
    }

    // ç‚¹å‡»ç›®å½•æ¡ç›®æå–å¯¹åº”åŒºé—´
    async function handleRangeClick(idx) {
      const toc = window._tocList || [];
      if (!toc.length) return;
      const offset = +$('#pageOffsetInput').value || 0;
      const extra  = +$('#extraPagesInput').value || 0;
      const start  = toc[idx].page + offset;
      const next   = toc[idx+1];
      const end    = (next ? next.page - 1 : window._lastPdfPages) + offset + extra;
      await extractRange(start, end);
    }
  </script>
</body>
</html>
