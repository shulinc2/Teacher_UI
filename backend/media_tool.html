 <!DOCTYPE html> 
 <html lang="zh"> 
 <head> 
  <meta charset="UTF-8" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>Media Tool</title> 
  <!-- Add Markdown rendering library --> 
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> 
  <!-- ADDED: html-to-docx library --> 
  <script src="https://unpkg.com/html-to-docx@1.8.0/dist/html-to-docx.js"></script> 
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
<script src="https://unpkg.com/react@16.4.1/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@16.4.1/umd/react-dom.production.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/progressbar.js/1.1.0/progressbar.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
<script src="https://canpanion-dev-reactcomponent.s3.ap-southeast-2.amazonaws.com/AIGC_Media/bundle.js"></script>
<style> 
 	 .container { 
 		 width: 100%; 
 		 max-width: 700px; 
 		 background: white; 
 		 padding: 25px 30px; 
 		 border-radius: 12px; 
 		 box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
 	 } 
 	 .control-group { 
 		 display: flex; 
 		 flex-direction: column; 
 		 gap: 5px; 
 	 } 
 	 label { 
 		 font-weight: 500; 
 		 color: #374151; 
 		 font-size: 14px; 
 	 } 
 	 .language-select { 
 	 	 position: relative; 
 	 	 width: 250px; 
 	 } 
 	 .language-select select { 
 	 	 width: 100%; 
 	 	 padding: 10px 16px; 
 	 	 border: 1px solid #d1d5db; 
 	 	 border-radius: 8px; 
 	 	 cursor: pointer; 
 	 	 background: white; 
 	 	 color: #333; 
 	 	 font-size: 14px; 
 	 	 appearance: none; 
 	 	 -webkit-appearance: none; 
 	 	 -moz-appearance: none; 
 	 	 transition: border-color 0.2s, box-shadow 0.2s; 
 	 } 
 	 .language-select::after { 
 	 	 content: "‚ñº"; 
 	 	 font-size: 12px; 
 	 	 color: #6b7280; 
 	 	 position: absolute; 
 	 	 right: 15px; 
 	 	 top: 50%; 
 	 	 transform: translateY(-50%); 
 	 	 pointer-events: none; 
 	 } 
 	 .language-select select:hover { 
 	 	 border-color: #9ca3af; 
 	 } 
 	 .language-select select:focus { 
 	 	 outline: none; 
 	 	 border-color: #3b82f6; 
 	 	 box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); 
 	 } 
 	 h2 { 
 		 color: #1f2937; 
 		 text-align: center; 
     font-size: 24px !important;
     margin-bottom: 16px !important;
 	 } 
 	 .mode-switch { 
 	 	 margin: 20px 0; 
 	 	 display: flex; 
 	 	 gap: 10px; 
 	 	 justify-content: space-between; 
 	 	 flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */ 
 	 } 
 	 .mode-button { 
 	 	 padding: 12px 24px; 
 	 	 border: 1px solid #d1d5db; 
 	 	 border-radius: 8px; 
 	 	 cursor: pointer; 
 	 	 background: white; 
 	 	 color: #374151; 
 	 	 transition: all 0.2s ease-in-out; 
 	 	 font-size: 15px; 
 	 	 font-weight: 500; 
 	 	 box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
 	 	 flex-grow: 1; 
 	 	 text-align: center; 
 	 } 
 	 .mode-button:hover { 
 	 	 background: #f3f4f6; 
 	 	 transform: translateY(-1px); 
 	 	 box-shadow: 0 3px 6px rgba(0,0,0,0.08); 
 	 } 
 	 .mode-button.selected { 
 	 	 background: #3b82f6; 
 	 	 color: white; 
 	 	 border-color: #3b82f6; 
 	 	 box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2); 
 	 } 
 	 #submitBtn, #exportBtn { /* UPDATED */ 
 	 	 display: block; 
 	 	 width: 100%; 
 	 	 padding: 12px 24px; 
 	 	 border: none; 
 	 	 border-radius: 8px; 
 	 	 cursor: pointer; 
 	 	 font-size: 16px; 
 	 	 font-weight: 600; 
 	 	 transition: all 0.2s ease-in-out; 
 	 	 box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
 	 } 
 	 #submitBtn { 
 	 	 background: #22c55e; 
 	 	 color: white; 
 	 } 
 	 #submitBtn:hover { 
 	 	 background: #16a34a; 
 	 	 transform: translateY(-1px); 
 	 	 box-shadow: 0 3px 6px rgba(0,0,0,0.1); 
 	 } 
 	 /* ADDED: Export button styles */ 
 	 #exportBtn { 
 	 	 background: #0ea5e9; /* Light blue */ 
 	 	 color: white; 
 	 } 
 	 #exportBtn:hover { 
 	 	 background: #0284c7; /* Darker blue */ 
 	 	 transform: translateY(-1px); 
 	 	 box-shadow: 0 3px 6px rgba(0,0,0,0.1); 
 	 } 
 	 #exportBtn:disabled { 
 	 	 background: #e5e7eb; 
 	 	 color: #9ca3af; 
 	 	 cursor: not-allowed; 
 	 	 transform: none; 
 	 	 box-shadow: none; 
 	 } 
 	 #loading { 
 	 	 display: none; 
 	 	 color: #4b5563; 
 	 	 margin: 15px 0; 
 	 	 text-align: center; 
 	 } 
 	 .input-group { 
 		 display: flex; 
 		 flex-direction: column; 
 		 gap: 15px; /* Increased gap for better spacing */ 
 	 } 
 	 .input-wrapper { 
 		 position: relative; 
 		 display: flex; 
 		 align-items: center; 
 	 } 
 	 input[type="file"], input[type="url"] { 
 	 	 width: 100%; 
 	 	 padding: 10px; 
 	 	 border: 1px solid #d1d5db; 
 	 	 border-radius: 8px; 
 	 	 box-sizing: border-box; /* Important */ 
 	 	 transition: background-color 0.2s; 
 	 } 
 	 input[type="file"]:disabled, input[type="url"]:disabled { 
 		 background-color: #f3f4f6; 
 		 cursor: not-allowed; 
 		 color: #9ca3af; 
 	 } 
 	 .clear-btn { 
 		 position: absolute; 
 		 right: 10px; 
 		 top: 50%; 
 		 transform: translateY(-50%); 
 		 background: #9ca3af; 
 		 color: white; 
 		 border: none; 
 		 border-radius: 50%; 
 		 width: 22px; 
 		 height: 22px; 
 		 cursor: pointer; 
 		 font-weight: bold; 
 		 display: flex; 
 		 align-items: center; 
 		 justify-content: center; 
 		 font-size: 12px; 
 		 line-height: 22px; 
 		 padding: 0; 
 		 display: none; /* Hidden by default */ 
 	 } 
 	 .clear-btn:hover { 
 		 background: #6b7280; 
 	 } 
 	 .markdown-content { 
 	 	 background: #ffffff; 
 	 	 padding: 25px; 
 	 	 border-radius: 10px; 
 	 	 margin-top: 20px; 
 	 	 box-shadow: 0 2px 8px rgba(0,0,0,0.07); 
 	 	 line-height: 1.7; 
 	 	 font-size: 16px; 
        min-height: 150px;
 	 } 
 	 .result-header { 
 	 	 display: flex; 
 	 	 align-items: center; 
 	 	 margin-bottom: 15px; 
 	 	 padding-bottom: 10px; 
 	 	 border-bottom: 1px solid #e5e7eb; 
 	 } 
 	 .result-header .emoji { 
 	 	 font-size: 24px; 
 	 	 margin-right: 12px; 
 	 } 
 	 .result-header .title { 
 	 	 font-size: 18px; 
 	 	 font-weight: 600; 
 	 	 color: #111827; 
 	 } 
 	 .result-content { 
 	 	 color: #374151; 
 	 	 word-wrap: break-word; 
 	 } 
    .result-content p {
        margin-bottom: 1em; /* Spacing between paragraphs */
    }
 	 .recognizing-text { 
 		 color: #6b7280; 
 		 font-style: italic; 
 		 margin-top: 10px; 
 		 padding: 5px; 
 		 min-height: 24px; 
 	 } 
 	 .button-container { 
 	 	 display: flex; 
 	 	 flex-direction: column; 
 	 	 align-items: center; 
 	 	 width: 100%; 
 	 	 gap: 10px; 
 	 } 
 	 /* ADDED: Container for action buttons */ 
 	 .action-buttons { 
 		 display: flex; 
 		 gap: 10px; 
 		 width: 100%; 
 	 } 
 	 #error-message { 
 		 color: #ef4444; 
 		 background-color: #fee2e2; 
 		 border: 1px solid #fca5a5; 
 		 padding: 10px; 
 		 border-radius: 8px; 
 		 margin-bottom: 15px; 
 		 display: none; /* Hidden by default */ 
 		 text-align: center; 
 	 } 
  </style> 
 </head> 
 <body> 
 <div class="container"> 
  <h2 id="title">üéôÔ∏è Upload Audio or üì∫ Paste Video Link</h2> 
   
  <div id="error-message"></div> 

  <div class="input-group"> 
    <div class="input-wrapper"> 
 		 <input type="file" id="media" accept="audio/*,video/*"> 
 		 <button id="clearFileBtn" class="clear-btn" title="Clear file selection">√ó</button> 
    </div> 
    <div class="input-wrapper"> 
 		 <input type="url" id="videoLink" placeholder="Paste YouTube video link"> 
 		 <button id="clearUrlBtn" class="clear-btn" title="Clear URL">√ó</button> 
    </div> 
    <div class="control-group"> 
 	 <label id="videoLangLabel" for="videoLanguageSelect">Video Language</label> 
 	 <div class="language-select"> 
 		  <select id="videoLanguageSelect"> 
 			  <option value="en-US">English (US)</option> 
 			  <option value="zh-CN">ÊôÆÈÄöË©± (CN)</option> 
 			  <option value="zh-HK">Âª£Êù±Ë©± (HK)</option> 
 			  <option value="zh-TW">ÂúãË™û (TW)</option> 
 		  </select> 
 	 </div> 
    </div> 
  </div> 
   
  <div class="button-container"> 
    <div class="mode-switch"> 
 	 <button id="transcriptBtn" type="button" class="mode-button" onclick="switchMode('transcript')">üìù Show Full Text</button> 
 	 <button id="summaryBtn" type="button" class="mode-button" onclick="switchMode('summary')">üßë‚Äçüè´ Generate Summary</button> 
 	 <button id="minutesBtn" type="button" class="mode-button" onclick="switchMode('minutes')">üìù Minutes</button> 
    </div> 
    <!-- UPDATED: Wrapped buttons in a container --> 
    <div class="action-buttons"> 
 	 <!-- FIX: Added type="button" to prevent default form submission behavior --> 
 	 <button type="button" onclick="processMedia()" id="submitBtn" style="flex-grow: 1;">Submit</button> 
 	 <!-- FIX: Added type="button" for consistency --> 
 	 <button type="button" id="exportBtn" style="flex-grow: 1;">Export</button> 
    </div> 
  </div> 
   
  <div id="loading">Processing...</div> 

  <div id="out" class="markdown-content"> 
    <div class="result-header"> 
 	 <span class="emoji">üóíÔ∏è</span> 
 	 <span class="title">Result</span> 
    </div> 
    <div class="result-content">Waiting for input...</div> 
  </div> 
 </div> 

  <script> 
 	 window.currentTeacher=JSON.parse(localStorage.getItem('userInfo')); 
 	 // --- 1. CONFIGURATION --- 
 	 const translations = { 
 		 'en': {  
 			 title: 'üéôÔ∏è Upload Audio or üì∫ Paste Video Link',  
 			 videoLinkPlaceholder: 'or paste YouTube video link',  
 			 transcriptBtn: 'üóíÔ∏è Full Text',  
 			 summaryBtn: 'üßë‚Äçüè´ Brief Summary',  
 			 minutesBtn: 'üìù Minutes',  
 			 submitBtn: 'Submit',  
 			 loading: 'Processing...',  
 			 waiting: 'Waiting for input...',  
 			 noInput: 'Please upload an audio file or paste a video link!', 
 			 noLang: 'Please select a video language!', 
 			 processingError: 'Request failed: ',  
 			 error: 'Error: ',  
 			 videoLangLabel: 'Resource Language', 
 			 resultTitle: 'Result', 
 			 fullTextTitle: 'Full Text', 
 			 invalidIdError: 'Cannot generate content because the history ID is missing or invalid. Please re-process the original media.', 
 			 historySaveError: "Processing complete, but could not save to history. Summary/Minutes are disabled.", 
 			 exportButton: 'Export to DOCX',
 			 exporting: 'Exporting...',
 			 noContentToExport: 'There is no content to export yet.',
              generatePlaceholder: 'Click "Submit" to generate content for this mode.',
 		 }, 
 		 'zh': {  
 			 title: 'üéôÔ∏è ‰∏ä‰º†Èü≥È¢ë Êàñ üì∫ Á≤òË¥¥ËßÜÈ¢ëÈìæÊé•',  
 			 videoLinkPlaceholder: 'ÊàñÁ≤òË¥¥ YouTube ËßÜÈ¢ëÈìæÊé•',  
 			 transcriptBtn: 'üìù ÂÖ®Êñá',  
 			 summaryBtn: 'üßë‚Äçüè´ ÊëòË¶Å',  
 			 minutesBtn: 'üìù ‰ºöËÆÆÁ∫™Ë¶Å',  
 			 submitBtn: 'Êèê‰∫§Â§ÑÁêÜ',  
 			 loading: 'Â§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂÄô...',  
 			 waiting: 'Á≠âÂæÖËæìÂÖ•...',  
 			 noInput: 'ËØ∑‰∏ä‰º†‰∏Ä‰∏™Èü≥È¢ëÊñá‰ª∂ÊàñÁ≤òË¥¥ËßÜÈ¢ëÈìæÊé•ÔºÅ', 
 			 noLang: 'ËØ∑ÈÄâÊã©ËßÜÈ¢ëËØ≠Ë®ÄÔºÅ', 
 			 processingError: 'ËØ∑Ê±ÇÂ§±Ë¥•Ôºö',  
 			 error: 'ÈîôËØØÔºö',  
 			 videoLangLabel: 'ËµÑÊ∫êËØ≠Ë®Ä', 
 			 resultTitle: 'ÁªìÊûú', 
 			 fullTextTitle: 'ÂÖ®Êñá', 
 			 invalidIdError: 'Êó†Ê≥ïÁîüÊàêÂÜÖÂÆπÔºåÂõ†‰∏∫ÂéÜÂè≤ËÆ∞ÂΩïID‰∏¢Â§±ÊàñÊó†Êïà„ÄÇËØ∑ÈáçÊñ∞Â§ÑÁêÜÂéüÂßãÂ™í‰Ωì„ÄÇ', 
 			 historySaveError: "Â§ÑÁêÜÂÆåÊàêÔºå‰ΩÜÊó†Ê≥ï‰øùÂ≠òÂà∞ÂéÜÂè≤ËÆ∞ÂΩï„ÄÇÊëòË¶Å/‰ºöËÆÆÁ∫™Ë¶ÅÂäüËÉΩÂ∑≤Á¶ÅÁî®„ÄÇ", 
 			 exportButton: 'Ê±áÂá∫‰∏∫ DOCX',
 			 exporting: 'Ê±áÂá∫‰∏≠...',
 			 noContentToExport: 'Â∞öÊó†ÂÜÖÂÆπÂèØÊ±áÂá∫„ÄÇ',
              generatePlaceholder: 'ËØ∑ÁÇπÂáª‚ÄúÊèê‰∫§‚Äù‰ª•ÁîüÊàêÊ≠§Ê®°ÂºèÁöÑÂÜÖÂÆπ„ÄÇ',
 		 }, 
 		 'zh-Hant': {  
 			 title: 'üéôÔ∏è ‰∏äÂÇ≥Èü≥È†ª Êàñ üì∫ Ë≤º‰∏äË¶ñÈ†ªÈÄ£Áµê',  
 			 videoLinkPlaceholder: 'ÊàñË≤º‰∏ä YouTube Ë¶ñÈ†ªÈÄ£Áµê',  
 			 transcriptBtn: 'üóíÔ∏è ÂÖ®Êñá',  
 			 summaryBtn: 'üßë‚Äçüè´ ÊëòË¶Å',  
 			 minutesBtn: 'üìù ÊúÉË≠∞Á¥ÄË¶Å',  
 			 submitBtn: 'Êèê‰∫§ËôïÁêÜ',  
 			 loading: 'ËôïÁêÜ‰∏≠ÔºåË´ãÁ®çÂÄô...',  
 			 waiting: 'Á≠âÂæÖËº∏ÂÖ•...',  
 			 noInput: 'Ë´ã‰∏äÂÇ≥‰∏ÄÂÄãÈü≥È†ªÊñá‰ª∂ÊàñË≤º‰∏äË¶ñÈ†ªÈÄ£ÁµêÔºÅ', 
 			 noLang: 'Ë´ãÈÅ∏ÊìáË¶ñË®äË™ûË®ÄÔºÅ', 
 			 processingError: 'Ë´ãÊ±ÇÂ§±ÊïóÔºö',  
 			 error: 'ÈåØË™§Ôºö', 
 			 videoLangLabel: 'Ë≥áÊ∫êË™ûË®Ä', 
 			 resultTitle: 'ÁµêÊûú', 
 			 fullTextTitle: 'ÂÖ®Êñá', 
 			 invalidIdError: 'ÁÑ°Ê≥ïÁîüÊàêÂÖßÂÆπÔºåÂõ†ÁÇ∫Ê≠∑Âè≤Ë®òÈåÑID‰∏üÂ§±ÊàñÁÑ°Êïà„ÄÇË´ãÈáçÊñ∞ËôïÁêÜÂéüÂßãÂ™íÈ´î„ÄÇ', 
 			 historySaveError: "ËôïÁêÜÂÆåÊàêÔºå‰ΩÜÁÑ°Ê≥ï‰øùÂ≠òÂà∞Ê≠∑Âè≤Ë®òÈåÑ„ÄÇÊëòË¶Å/ÊúÉË≠∞Á¥ÄË¶ÅÂäüËÉΩÂ∑≤Á¶ÅÁî®„ÄÇ", 
 			 exportButton: 'ÂåØÂá∫ÁÇ∫ DOCX',
 			 exporting: 'ÂåØÂá∫‰∏≠...',
 			 noContentToExport: 'Â∞öÁÑ°ÂÖßÂÆπÂèØÂåØÂá∫„ÄÇ',
              generatePlaceholder: 'Ë´ãÈªûÊìä„ÄåÊèê‰∫§„Äç‰ª•ÁîüÊàêÊ≠§Ê®°ÂºèÁöÑÂÖßÂÆπ„ÄÇ',
 		 } 
 	 }; 
 	  
 	 // --- Global State ---
 	 let uiLang = 'en'; 
 	 const cachedData = { transcript: null, summary: null, minutes: null, currentMode: 'transcript' }; 
      // NEW: State for managing in-progress streaming
     let isStreamingTranscript = false;
     let streamedTranscriptParagraphs = [];
     let recognizingText = '';

 	 // DOM Elements (initialized in DOMContentLoaded)
 	 let transcriptBtn, summaryBtn, minutesBtn, modeButtons, loadingEl, outDiv, 
 		 mediaInput, videoLinkInput, clearFileBtn, clearUrlBtn, errorMsgEl, exportBtn; 

 	 // --- 2. CORE & HELPER FUNCTIONS --- 

 	 const isValidObjectId = (id) => typeof id === 'string' && /^[0-9a-fA-F]{24}$/.test(id); 

 	 function showMessage(message, isError = true) { 
 		 errorMsgEl.textContent = message; 
 		 errorMsgEl.style.backgroundColor = isError ? '#fee2e2' : '#dcfce7'; 
 		 errorMsgEl.style.color = isError ? '#ef4444' : '#166534'; 
 		 errorMsgEl.style.borderColor = isError ? '#fca5a5' : '#86efac'; 
 		 errorMsgEl.style.display = 'block'; 
 	 } 

 	 function hideMessage() { 
 		 errorMsgEl.style.display = 'none'; 
 	 } 

 	 function setUiLanguage(lang) { 
 		 const t = translations[lang] || translations[lang.split('-')[0]] || translations['en']; 
 		 uiLang = lang;  

 		 document.getElementById('title').textContent = t.title; 
 		 videoLinkInput.placeholder = t.videoLinkPlaceholder; 
 		 document.getElementById('videoLangLabel').textContent = t.videoLangLabel; 
 		 transcriptBtn.textContent = t.transcriptBtn; 
 		 summaryBtn.textContent = t.summaryBtn; 
 		 minutesBtn.textContent = t.minutesBtn; 
 		 document.getElementById('submitBtn').textContent = t.submitBtn; 
 		 exportBtn.textContent = t.exportButton; 
 		 loadingEl.textContent = t.loading; 
 		  
 		 const resultTitleEl = outDiv.querySelector('.title'); 
 		 if (resultTitleEl && resultTitleEl.textContent === (translations[uiLang]?.resultTitle || 'Result')) { 
 			  resultTitleEl.textContent = t.resultTitle; 
 		 } 
 		  
 		 const resultContentEl = outDiv.querySelector('.result-content'); 
 		 if(resultContentEl && resultContentEl.textContent === (translations[uiLang]?.waiting || 'Waiting for input...')){ 
 			  resultContentEl.textContent = t.waiting; 
 		 } 
 	 } 

 	 function setMode(mode) { 
 		 cachedData.currentMode = mode; 
 		 modeButtons.forEach(b => b.classList.remove('selected')); 
 		 document.getElementById(`${mode}Btn`).classList.add('selected'); 
 	 } 

    /**
     * NEW: Resets all data and UI to the initial state.
     */
    function resetState() {
        hideMessage();
        // Clear all cached results and streaming state
        Object.keys(cachedData).forEach(key => {
            if (key !== 'currentMode') cachedData[key] = null;
        });
        isStreamingTranscript = false;
        streamedTranscriptParagraphs = [];
        recognizingText = '';

        // Reset UI to initial state
        const t = translations[uiLang] || translations['en'];
        outDiv.innerHTML = `
            <div class="result-header">
                <span class="emoji">üóíÔ∏è</span>
                <span class="title">${t.resultTitle}</span>
            </div>
            <div class="result-content">${t.waiting}</div>
        `;
        exportBtn.disabled = true;
        // We don't switch mode here, let the user decide.
    }

 	 /** * REWRITTEN: Handles switching modes with better state management.
 	  */ 
 	 function switchMode(mode) { 
 		 setMode(mode); 
 		 const modeState = cachedData[mode]; 

         // If user clicks on transcript tab while it's actively streaming,
         // re-render the streaming view from the current state.
         if (mode === 'transcript' && isStreamingTranscript) {
             displayStreamingTranscriptState();
             return;
         }

 		 if (modeState === 'loading') { 
 			 displayLoadingState(mode); 
 		 } else if (modeState) { 
 			 displayResult(mode, modeState); 
 		 } else {
            // If no data and not loading, show an empty state for the selected mode.
            displayEmptyState(mode);
         }
 	 } 

 	 /** * Renders the final result in the output container. 
 	  */ 
 	 function displayResult(mode, data) { 
 		 const t = translations[uiLang] || translations['en']; 
 		 let textToRender = ''; 

 		 if (!data) { 
 			 textToRender = 'No content available.'; 
 		 } else if (mode === 'transcript') { 
 			 textToRender = data.transcript || 'No transcript available.'; 
 		 } else if (mode === 'summary' || mode === 'minutes') { 
 			 const contentObject = data[mode] || data;  
 			 if (typeof contentObject === 'object' && contentObject !== null) { 
 				  textToRender = contentObject[uiLang] || contentObject[uiLang.split('-')[0]] || contentObject['en'] || 'Content not available for the selected language.'; 
 			 } else if (typeof contentObject === 'string') { 
 				  textToRender = contentObject; 
 			 } else { 
 				  textToRender = 'No content available for this mode.'; 
 			 } 
 		 } 

 		 let title, emoji; 
 		 if (mode === 'transcript') { 
 			 title = t.fullTextTitle; 
 			 emoji = 'üóíÔ∏è'; 
 		 } else if (mode === 'summary') { 
 			 title = t.summaryBtn.replace(/üßë‚Äçüè´/g, '').trim(); 
 			 emoji = '‚Äçüßë‚Äçüè´'; 
 		 } else if (mode === 'minutes') { 
 			 title = t.minutesBtn.replace(/üìù/g, '').trim(); 
 			 emoji = 'üìù'; 
 		 } 

 		 if (typeof textToRender !== 'string') { 
 			 console.error("Invalid data passed to displayResult. Expected string, got:", textToRender); 
 			 textToRender = "Error: Invalid content format."; 
 		 } 
 		  
 		 const content = `<div class="result-header"><span class="emoji">${emoji}</span><span class="title">${title}</span></div> 
 						   <div class="result-content">${marked.parse(textToRender)}</div>`; 
 		 outDiv.innerHTML = content; 
 		 exportBtn.disabled = false; 
 	 } 

    /**
     * NEW: Renders the view for a mode that has no data yet.
     */
    function displayEmptyState(mode) {
        const t = translations[uiLang] || translations['en'];
        let title, emoji;

        if (mode === 'summary') {
            title = t.summaryBtn.replace(/üßë‚Äçüè´/g, '').trim();
            emoji = 'üßë‚Äçüè´';
        } else if (mode === 'minutes') {
            title = t.minutesBtn.replace(/üìù/g, '').trim();
            emoji = 'üìù';
        } else { // Includes 'transcript' when there's no data
            title = t.fullTextTitle;
            emoji = 'üóíÔ∏è';
        }

        const emptyMessage = cachedData.transcript?.id ? t.generatePlaceholder : t.waiting;

        const content = `
            <div class="result-header"><span class="emoji">${emoji}</span><span class="title">${title}</span></div>
            <div class="result-content">${emptyMessage}</div>
        `;
        outDiv.innerHTML = content;
        exportBtn.disabled = !cachedData.transcript;
    }

 	 /** * Renders a loading state in the output container.
 	  */ 
 	 function displayLoadingState(mode) { 
 		 const t = translations[uiLang] || translations['en']; 
 		 let title, emoji; 

 		 if (mode === 'summary') { 
 			 title = t.summaryBtn.replace(/üßë‚Äçüè´/g, '').trim(); 
 			 emoji = 'üßë‚Äçüè´'; 
 		 } else if (mode === 'minutes') { 
 			 title = t.minutesBtn.replace(/üìù/g, '').trim(); 
 			 emoji = 'üìù'; 
 		 } else { 
 			 title = t.fullTextTitle; 
 			 emoji = 'üóíÔ∏è'; 
 		 } 

 		 const loadingMessage = `‚è≥ ${t.loading}`; 
 		 const content = `<div class="result-header"><span class="emoji">${emoji}</span><span class="title">${title}</span></div> 
 						   <div class="result-content">${marked.parse(loadingMessage)}</div>`; 
 		 outDiv.innerHTML = content; 
 		 exportBtn.disabled = true; 
 	 } 

    /**
     * NEW: Renders the real-time streaming transcript view from state.
     */
    function displayStreamingTranscriptState() {
        const t = translations[uiLang] || translations['en'];
        const streamingTitle = t.fullTextTitle + " (Streaming)";

        // Set the container structure
        outDiv.innerHTML = `
            <div class="result-header">
                <span class="emoji">üìù</span><span class="title">${streamingTitle}</span>
            </div>
            <div class="result-content" id="transcript-content"></div>
            <div class="recognizing-text" id="recognizing-content"></div>
        `;

        // Get the new elements
        const transcriptContentEl = document.getElementById('transcript-content');
        const recognizingContentEl = document.getElementById('recognizing-content');

        // Populate with current state
        streamedTranscriptParagraphs.forEach(pText => {
            const p = document.createElement('p');
            p.textContent = pText;
            transcriptContentEl.appendChild(p);
        });
        recognizingContentEl.textContent = recognizingText;

        exportBtn.disabled = true;
    }

 	 /** * Makes a non-streaming request for summaries and minutes. 
 	  */ 
 	 async function requestFullBody(params) { 
 		 const t = translations[uiLang] || translations['en']; 
 		 const modeToGenerate = cachedData.currentMode; 

 		 cachedData[modeToGenerate] = 'loading'; 
 		 displayLoadingState(modeToGenerate); 
 		 loadingEl.style.display = 'none'; 

 		 const userId = window.currentTeacher?.tid || 'test-user-id'; 
 		 const payload = { 
 			 mode: modeToGenerate, 
 			 locale: document.getElementById('videoLanguageSelect').value, 
 			 userId: userId, 
 			 reuseId: params.reuseId, 
 		 }; 
 		  
 		 try { 
 			 const res = await fetch('https://backend.canpaniongroup.com/aigc/process-media', { 
 				 method: 'POST', 
 				 headers: { 'Content-Type': 'application/json' }, 
 				 body: JSON.stringify(payload) 
 			 }).then(r => r.json()); 

 			 if (res.error) throw new Error(res.error); 
 			  
 			 if (res.summary) cachedData.summary = { id: res.id, ...res.summary }; 
 			 if (res.minutes) cachedData.minutes = { id: res.id, ...res.minutes }; 
 			  
 			 if (cachedData.currentMode === modeToGenerate) { 
 				 displayResult(modeToGenerate, res); 
 			 } 
 		 } catch (e) { 
 			 cachedData[modeToGenerate] = null; 
 			 if (cachedData.currentMode === modeToGenerate) { 
 				 outDiv.innerHTML = `<div class="result-content">${marked.parse(`‚ùå ${t.error}${e.message}`)}</div>`; 
 			 } 
 		 } 
 	 } 

 	 /** * Main function to process media. 
 	  */ 
 	 async function processMedia() { 
 		 hideMessage(); 
 		 const videoLang = document.getElementById('videoLanguageSelect').value; 
 		 const mediaFile = mediaInput.files[0]; 
 		 const videoLink = videoLinkInput.value; 
 		 const t = translations[uiLang] || translations['en']; 

 		 if (!videoLang) { 
 			 showMessage(t.noLang); 
 			 return; 
 		 } 
 		 if (!mediaFile && !videoLink && !cachedData.transcript?.id) { 
 			 showMessage(t.noInput); 
 			 return; 
 		 } 

 		 if (cachedData.currentMode !== 'transcript') { 
 			 if (!isValidObjectId(cachedData.transcript?.id)) { 
 				 showMessage(t.invalidIdError, true); 
 				 return; 
 			 } 
 			 return requestFullBody({ reuseId: cachedData.transcript.id }); 
 		 } 

 		 if(cachedData.transcript) { 
 			 return displayResult('transcript', cachedData.transcript); 
 		 } 
 		  
 		 // Reset state for new transcript generation
        isStreamingTranscript = true;
        streamedTranscriptParagraphs = [];
        recognizingText = '';
 		 exportBtn.disabled = true; 
 		  
 		 loadingEl.style.display = 'block'; 
         displayStreamingTranscriptState();
 		  
 		 const form = new FormData(); 
 		 form.append('mode', 'transcript'); 
 		 form.append('locale', videoLang); 
 		 const userId = window.currentTeacher?.tid || 'test-user-id'; 
 		 form.append('userId', userId); 
 		 mediaFile ? form.append('media', mediaFile) : form.append('videoUrl', videoLink); 

 		 try { 
 			 const response = await fetch('https://backend.canpaniongroup.com/aigc/process-media', { method: 'POST', body: form }); 
 			 if (!response.ok) { 
 				 const errText = await response.text(); 
 				 throw new Error(`Server error: ${response.status} ${errText}`); 
 			 } 

 			 const reader = response.body.getReader(); 
 			 const decoder = new TextDecoder(); 
 			 let buffer = ''; 

 			 while (true) { 
 				 const { done, value } = await reader.read(); 
 				 if (done) break; 

 				 buffer += decoder.decode(value, { stream: true }); 
 				 const sseMessages = buffer.split('\n\n'); 
 				 buffer = sseMessages.pop(); 

 				 for (const msg of sseMessages) { 
 					 if (msg.startsWith('data: ')) { 
 						 const jsonString = msg.substring(6); 
 						 if (!jsonString) continue; 
 						 try { 
 							 const data = JSON.parse(jsonString); 
 							 if (data.type === 'chunk') {
                                // 1. Update state
                                streamedTranscriptParagraphs.push(data.content);
                                recognizingText = '';
                                // 2. Update DOM if visible
                                const transcriptContentEl = document.getElementById('transcript-content');
                                if (transcriptContentEl) {
                                    const p = document.createElement('p');
                                    p.textContent = data.content;
                                    transcriptContentEl.appendChild(p);
                                    document.getElementById('recognizing-content').innerText = '';
                                }
 							 } else if (data.type === 'recognizing') { 
                                // 1. Update state
                                recognizingText = data.content;
                                // 2. Update DOM if visible
                                const recognizingContentEl = document.getElementById('recognizing-content');
                                if (recognizingContentEl) {
                                    recognizingContentEl.innerText = data.content;
                                }
 							 } else if (data.type === 'end') { 
                                 // Construct the final transcript from the streamed paragraphs to preserve formatting.
                                 const finalTranscriptText = streamedTranscriptParagraphs.join('\n\n');

 								 if (data.id && isValidObjectId(data.id)) { 
 									 cachedData.transcript = {  
 										 id: data.id,  
 										 transcript: finalTranscriptText,  // Use the paragraph-formatted text
 										 engine: data.engine  
 									 }; 
 								 } else { 
 									 console.error("Server returned an invalid history ID.", data.id); 
 									 cachedData.transcript = { 
                                         id: null, 
                                         transcript: finalTranscriptText, // Use the paragraph-formatted text
                                         engine: data.engine 
                                     }; 
 									 showMessage(t.historySaveError, false); 
 								 } 
                                 // Only display the final result if the user is still on the transcript tab
                                 if (cachedData.currentMode === 'transcript') {
 								    displayResult('transcript', cachedData.transcript); 
                                 }
 								 return; // End of stream processing
 							 } else if (data.type === 'error') { 
 								 throw new Error(`Transcription service error: ${data.message}`); 
 							 } 
 						 } catch(e) { 
 							 console.error("Failed to parse SSE message chunk:", jsonString, e); 
 						 } 
 					 } 
 				 } 
 			 } 
 		 } catch (e) { 
 			 outDiv.innerHTML += `<div class="result-content">${marked.parse(`‚ùå ${t.error}${e.message}`)}</div>`; 
 		 } finally { 
             isStreamingTranscript = false;
 			 loadingEl.style.display = 'none'; 
             // Clear any lingering "recognizing" text from the final view
             const recognizingEl = document.getElementById('recognizing-content');
 			 if (recognizingEl) recognizingEl.innerText = ''; 
 		 } 
 	 } 

 	 // --- EXPORT FUNCTION --- 
 	 async function handleExport() { 
 		 const t = translations[uiLang] || translations.en; 
 		 hideMessage(); 

 		 if (!cachedData.transcript && !cachedData.summary && !cachedData.minutes) { 
 			 showMessage(t.noContentToExport, true); 
 			 return; 
 		 } 

 		 if (typeof window.htmlDocx === 'undefined') { 
 			 showMessage('Exporter library is not ready. Please try again in a moment.', true); 
 			 return; 
 		 } 

 		 exportBtn.disabled = true; 
 		 exportBtn.textContent = t.exporting; 

 		 try { 
 			 const sourceName = mediaInput.files[0]?.name || videoLinkInput.value || 'MediaExport'; 
 			  
 			 const transcriptHtml = cachedData.transcript ? `<h2>${t.fullTextTitle}</h2>${marked.parse(cachedData.transcript.transcript || '')}` : ''; 
 			  
 			 const summaryHtml = cachedData.summary ? `<h2>${t.summaryBtn.replace(/üßë‚Äçüè´/g, '').trim()}</h2>` + Object.entries(cachedData.summary).filter(([key]) => key !== 'id').map(([lang, text]) => `<h3>(${lang})</h3>${marked.parse(text || '')}`).join('<hr/>') : ''; 
 			  
 			 const minutesHtml = cachedData.minutes ? `<h2>${t.minutesBtn.replace(/üìù/g, '').trim()}</h2>` + Object.entries(cachedData.minutes).filter(([key]) => key !== 'id').map(([lang, text]) => `<h3>(${lang})</h3>${marked.parse(text || '')}`).join('<hr/>') : ''; 

 			 const fullHtmlContent = ` 
 				 <!DOCTYPE html> 
 				 <html> 
 				 <head><meta charset="UTF-8"><title>${sourceName}</title></head> 
 				 <body> 
 					 <h1>${sourceName}</h1> 
 					 <hr/> 
 					 ${transcriptHtml} 
 					 <hr/> 
 					 ${summaryHtml} 
 					 <hr/> 
 					 ${minutesHtml} 
 				 </body> 
 				 </html> 
 			 `; 

 			 const fileBlob = await window.htmlDocx.asBlob(fullHtmlContent); 

 			 const link = document.createElement("a"); 
 			 link.href = URL.createObjectURL(fileBlob); 
 			 link.download = `${sourceName.replace(/[^a-zA-Z0-9]/g, '_')}.docx`; 
 			 document.body.appendChild(link); 
 			 link.click(); 
 			 document.body.removeChild(link); 
 			 URL.revokeObjectURL(link.href); 

 		 } catch (err) { 
 			 console.error('Error exporting file:', err); 
 			 showMessage(`${t.error}${err.message}`, true); 
 		 } finally { 
 			 exportBtn.disabled = false; 
 			 exportBtn.textContent = t.exportButton; 
 		 } 
 	 } 


 	 // --- 3. INITIALIZATION --- 
 	 document.addEventListener('DOMContentLoaded', () => { 
 		  
 		 // --- Get DOM Elements --- 
 		 transcriptBtn = document.getElementById('transcriptBtn'); 
 		 summaryBtn = document.getElementById('summaryBtn'); 
 		 minutesBtn = document.getElementById('minutesBtn'); 
 		 modeButtons = [transcriptBtn, summaryBtn, minutesBtn]; 
 		 loadingEl = document.getElementById('loading'); 
 		 outDiv = document.getElementById('out'); 
 		 mediaInput = document.getElementById('media'); 
 		 videoLinkInput = document.getElementById('videoLink'); 
 		 clearFileBtn = document.getElementById('clearFileBtn'); 
 		 clearUrlBtn = document.getElementById('clearUrlBtn'); 
 		 errorMsgEl = document.getElementById('error-message'); 
 		 exportBtn = document.getElementById('exportBtn'); 

 		 // --- Set Initial State --- 
 		 const initialLang = document.documentElement.lang || 'en'; 
 		 setUiLanguage(initialLang); 
 		 document.getElementById('videoLanguageSelect').value = 'en-US'; 
 		 setMode('transcript'); 
 		 exportBtn.disabled = true; 

 		 // --- Add Event Listeners --- 
 		 exportBtn.addEventListener('click', handleExport); 
 		 videoLinkInput.addEventListener('input', () => { 
 			 if (videoLinkInput.value.trim() !== '') { 
                resetState(); // Clear old results
 				 mediaInput.disabled = true; 
 				 clearUrlBtn.style.display = 'flex'; 
 			 } else { 
 				 mediaInput.disabled = false; 
 				 clearUrlBtn.style.display = 'none'; 
 			 } 
 		 }); 
 		 mediaInput.addEventListener('change', () => { 
 			 if (mediaInput.files.length > 0) { 
                resetState(); // Clear old results
 				 videoLinkInput.disabled = true; 
 				 clearFileBtn.style.display = 'flex'; 
 			 } else { 
 				 videoLinkInput.disabled = false; 
 				 clearFileBtn.style.display = 'none'; 
 			 } 
 		 }); 
 		 clearUrlBtn.addEventListener('click', () => { 
 			 videoLinkInput.value = ''; 
 			 mediaInput.disabled = false; 
 			 clearUrlBtn.style.display = 'none'; 
 			 videoLinkInput.focus(); 
             resetState(); // Clear old results
 		 }); 
 		 clearFileBtn.addEventListener('click', () => { 
 			 mediaInput.value = ''; 
 			 videoLinkInput.disabled = false; 
 			 clearFileBtn.style.display = 'none'; 
             resetState(); // Clear old results
 		 }); 
 	 }); 
  </script> 
 </body> 
 </html>
